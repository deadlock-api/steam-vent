// This file is generated by rust-protobuf 3.5.1. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `webuimessages_gamerecording.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::steam_vent_proto_common::protobuf::VERSION_3_7_2;

// @@protoc_insertion_point(message:CGameRecording_GetActiveTimelineApps_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_GetActiveTimelineApps_Request {
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_GetActiveTimelineApps_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_GetActiveTimelineApps_Request {
    fn default() -> &'a CGameRecording_GetActiveTimelineApps_Request {
        <CGameRecording_GetActiveTimelineApps_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_GetActiveTimelineApps_Request {
    pub fn new() -> CGameRecording_GetActiveTimelineApps_Request {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_GetActiveTimelineApps_Request {
    const NAME: &'static str = "CGameRecording_GetActiveTimelineApps_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_GetActiveTimelineApps_Request {
        CGameRecording_GetActiveTimelineApps_Request::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_GetActiveTimelineApps_Request {
        static instance: CGameRecording_GetActiveTimelineApps_Request = CGameRecording_GetActiveTimelineApps_Request {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_GetActiveTimelineApps_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_GetActiveTimelineApps_Response {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_GetActiveTimelineApps_Response.apps)
    pub apps: ::std::vec::Vec<cgame_recording_get_active_timeline_apps_response::App>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_GetActiveTimelineApps_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_GetActiveTimelineApps_Response {
    fn default() -> &'a CGameRecording_GetActiveTimelineApps_Response {
        <CGameRecording_GetActiveTimelineApps_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_GetActiveTimelineApps_Response {
    pub fn new() -> CGameRecording_GetActiveTimelineApps_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_GetActiveTimelineApps_Response {
    const NAME: &'static str = "CGameRecording_GetActiveTimelineApps_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.apps.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.apps {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.apps {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_GetActiveTimelineApps_Response {
        CGameRecording_GetActiveTimelineApps_Response::new()
    }

    fn clear(&mut self) {
        self.apps.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_GetActiveTimelineApps_Response {
        static instance: CGameRecording_GetActiveTimelineApps_Response = CGameRecording_GetActiveTimelineApps_Response {
            apps: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CGameRecording_GetActiveTimelineApps_Response`
pub mod cgame_recording_get_active_timeline_apps_response {
    // @@protoc_insertion_point(message:CGameRecording_GetActiveTimelineApps_Response.App)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct App {
        // message fields
        // @@protoc_insertion_point(field:CGameRecording_GetActiveTimelineApps_Response.App.game_id)
        pub game_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CGameRecording_GetActiveTimelineApps_Response.App.most_recent_start_time)
        pub most_recent_start_time: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CGameRecording_GetActiveTimelineApps_Response.App.recording_type)
        pub recording_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::super::enums::EGameRecordingType>>,
        // @@protoc_insertion_point(field:CGameRecording_GetActiveTimelineApps_Response.App.video_duration_seconds)
        pub video_duration_seconds: ::std::option::Option<f64>,
        // @@protoc_insertion_point(field:CGameRecording_GetActiveTimelineApps_Response.App.timeline_duration_seconds)
        pub timeline_duration_seconds: ::std::option::Option<f64>,
        // @@protoc_insertion_point(field:CGameRecording_GetActiveTimelineApps_Response.App.is_active)
        pub is_active: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CGameRecording_GetActiveTimelineApps_Response.App.file_size)
        pub file_size: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CGameRecording_GetActiveTimelineApps_Response.App.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a App {
        fn default() -> &'a App {
            <App as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl App {
        pub fn new() -> App {
            ::std::default::Default::default()
        }

        // optional uint64 game_id = 1;

        pub fn game_id(&self) -> u64 {
            self.game_id.unwrap_or(0)
        }

        pub fn clear_game_id(&mut self) {
            self.game_id = ::std::option::Option::None;
        }

        pub fn has_game_id(&self) -> bool {
            self.game_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_id(&mut self, v: u64) {
            self.game_id = ::std::option::Option::Some(v);
        }

        // optional uint32 most_recent_start_time = 2;

        pub fn most_recent_start_time(&self) -> u32 {
            self.most_recent_start_time.unwrap_or(0)
        }

        pub fn clear_most_recent_start_time(&mut self) {
            self.most_recent_start_time = ::std::option::Option::None;
        }

        pub fn has_most_recent_start_time(&self) -> bool {
            self.most_recent_start_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_most_recent_start_time(&mut self, v: u32) {
            self.most_recent_start_time = ::std::option::Option::Some(v);
        }

        // optional .EGameRecordingType recording_type = 3;

        pub fn recording_type(&self) -> super::super::enums::EGameRecordingType {
            match self.recording_type {
                Some(e) => e.enum_value_or(super::super::enums::EGameRecordingType::k_EGameRecordingType_Unknown),
                None => super::super::enums::EGameRecordingType::k_EGameRecordingType_Unknown,
            }
        }

        pub fn clear_recording_type(&mut self) {
            self.recording_type = ::std::option::Option::None;
        }

        pub fn has_recording_type(&self) -> bool {
            self.recording_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_recording_type(&mut self, v: super::super::enums::EGameRecordingType) {
            self.recording_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }

        // optional double video_duration_seconds = 4;

        pub fn video_duration_seconds(&self) -> f64 {
            self.video_duration_seconds.unwrap_or(0.)
        }

        pub fn clear_video_duration_seconds(&mut self) {
            self.video_duration_seconds = ::std::option::Option::None;
        }

        pub fn has_video_duration_seconds(&self) -> bool {
            self.video_duration_seconds.is_some()
        }

        // Param is passed by value, moved
        pub fn set_video_duration_seconds(&mut self, v: f64) {
            self.video_duration_seconds = ::std::option::Option::Some(v);
        }

        // optional double timeline_duration_seconds = 5;

        pub fn timeline_duration_seconds(&self) -> f64 {
            self.timeline_duration_seconds.unwrap_or(0.)
        }

        pub fn clear_timeline_duration_seconds(&mut self) {
            self.timeline_duration_seconds = ::std::option::Option::None;
        }

        pub fn has_timeline_duration_seconds(&self) -> bool {
            self.timeline_duration_seconds.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timeline_duration_seconds(&mut self, v: f64) {
            self.timeline_duration_seconds = ::std::option::Option::Some(v);
        }

        // optional bool is_active = 6;

        pub fn is_active(&self) -> bool {
            self.is_active.unwrap_or(false)
        }

        pub fn clear_is_active(&mut self) {
            self.is_active = ::std::option::Option::None;
        }

        pub fn has_is_active(&self) -> bool {
            self.is_active.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_active(&mut self, v: bool) {
            self.is_active = ::std::option::Option::Some(v);
        }

        // optional uint64 file_size = 7;

        pub fn file_size(&self) -> u64 {
            self.file_size.unwrap_or(0)
        }

        pub fn clear_file_size(&mut self) {
            self.file_size = ::std::option::Option::None;
        }

        pub fn has_file_size(&self) -> bool {
            self.file_size.is_some()
        }

        // Param is passed by value, moved
        pub fn set_file_size(&mut self, v: u64) {
            self.file_size = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for App {
        const NAME: &'static str = "App";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.game_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    16 => {
                        self.most_recent_start_time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.recording_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    33 => {
                        self.video_duration_seconds = ::std::option::Option::Some(is.read_double()?);
                    },
                    41 => {
                        self.timeline_duration_seconds = ::std::option::Option::Some(is.read_double()?);
                    },
                    48 => {
                        self.is_active = ::std::option::Option::Some(is.read_bool()?);
                    },
                    56 => {
                        self.file_size = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.game_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.most_recent_start_time {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.recording_type {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v.value());
            }
            if let Some(v) = self.video_duration_seconds {
                my_size += 1 + 8;
            }
            if let Some(v) = self.timeline_duration_seconds {
                my_size += 1 + 8;
            }
            if let Some(v) = self.is_active {
                my_size += 1 + 1;
            }
            if let Some(v) = self.file_size {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(7, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.game_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.most_recent_start_time {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.recording_type {
                os.write_enum(3, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.video_duration_seconds {
                os.write_double(4, v)?;
            }
            if let Some(v) = self.timeline_duration_seconds {
                os.write_double(5, v)?;
            }
            if let Some(v) = self.is_active {
                os.write_bool(6, v)?;
            }
            if let Some(v) = self.file_size {
                os.write_uint64(7, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> App {
            App::new()
        }

        fn clear(&mut self) {
            self.game_id = ::std::option::Option::None;
            self.most_recent_start_time = ::std::option::Option::None;
            self.recording_type = ::std::option::Option::None;
            self.video_duration_seconds = ::std::option::Option::None;
            self.timeline_duration_seconds = ::std::option::Option::None;
            self.is_active = ::std::option::Option::None;
            self.file_size = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static App {
            static instance: App = App {
                game_id: ::std::option::Option::None,
                most_recent_start_time: ::std::option::Option::None,
                recording_type: ::std::option::Option::None,
                video_duration_seconds: ::std::option::Option::None,
                timeline_duration_seconds: ::std::option::Option::None,
                is_active: ::std::option::Option::None,
                file_size: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CGameRecording_GetTimelinesForApp_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_GetTimelinesForApp_Request {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_GetTimelinesForApp_Request.game_id)
    pub game_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_GetTimelinesForApp_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_GetTimelinesForApp_Request {
    fn default() -> &'a CGameRecording_GetTimelinesForApp_Request {
        <CGameRecording_GetTimelinesForApp_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_GetTimelinesForApp_Request {
    pub fn new() -> CGameRecording_GetTimelinesForApp_Request {
        ::std::default::Default::default()
    }

    // optional uint64 game_id = 1;

    pub fn game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_GetTimelinesForApp_Request {
    const NAME: &'static str = "CGameRecording_GetTimelinesForApp_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.game_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.game_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.game_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_GetTimelinesForApp_Request {
        CGameRecording_GetTimelinesForApp_Request::new()
    }

    fn clear(&mut self) {
        self.game_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_GetTimelinesForApp_Request {
        static instance: CGameRecording_GetTimelinesForApp_Request = CGameRecording_GetTimelinesForApp_Request {
            game_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_GetTimelinesForApp_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_GetTimelinesForApp_Response {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_GetTimelinesForApp_Response.timelines)
    pub timelines: ::std::vec::Vec<super::webuimessages_gamerecordingfiles::CGameRecordingTimelineMetadata>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_GetTimelinesForApp_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_GetTimelinesForApp_Response {
    fn default() -> &'a CGameRecording_GetTimelinesForApp_Response {
        <CGameRecording_GetTimelinesForApp_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_GetTimelinesForApp_Response {
    pub fn new() -> CGameRecording_GetTimelinesForApp_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_GetTimelinesForApp_Response {
    const NAME: &'static str = "CGameRecording_GetTimelinesForApp_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.timelines.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.timelines {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.timelines {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_GetTimelinesForApp_Response {
        CGameRecording_GetTimelinesForApp_Response::new()
    }

    fn clear(&mut self) {
        self.timelines.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_GetTimelinesForApp_Response {
        static instance: CGameRecording_GetTimelinesForApp_Response = CGameRecording_GetTimelinesForApp_Response {
            timelines: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_GetTimelinesForClip_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_GetTimelinesForClip_Request {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_GetTimelinesForClip_Request.clip_id)
    pub clip_id: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_GetTimelinesForClip_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_GetTimelinesForClip_Request {
    fn default() -> &'a CGameRecording_GetTimelinesForClip_Request {
        <CGameRecording_GetTimelinesForClip_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_GetTimelinesForClip_Request {
    pub fn new() -> CGameRecording_GetTimelinesForClip_Request {
        ::std::default::Default::default()
    }

    // optional string clip_id = 1;

    pub fn clip_id(&self) -> &str {
        match self.clip_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_clip_id(&mut self) {
        self.clip_id = ::std::option::Option::None;
    }

    pub fn has_clip_id(&self) -> bool {
        self.clip_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clip_id(&mut self, v: ::std::string::String) {
        self.clip_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clip_id(&mut self) -> &mut ::std::string::String {
        if self.clip_id.is_none() {
            self.clip_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.clip_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_clip_id(&mut self) -> ::std::string::String {
        self.clip_id.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_GetTimelinesForClip_Request {
    const NAME: &'static str = "CGameRecording_GetTimelinesForClip_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.clip_id = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.clip_id.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.clip_id.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_GetTimelinesForClip_Request {
        CGameRecording_GetTimelinesForClip_Request::new()
    }

    fn clear(&mut self) {
        self.clip_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_GetTimelinesForClip_Request {
        static instance: CGameRecording_GetTimelinesForClip_Request = CGameRecording_GetTimelinesForClip_Request {
            clip_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_GetTimelinesForClip_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_GetTimelinesForClip_Response {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_GetTimelinesForClip_Response.game_id)
    pub game_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CGameRecording_GetTimelinesForClip_Response.timelines)
    pub timelines: ::std::vec::Vec<super::webuimessages_gamerecordingfiles::CGameRecordingTimelineMetadata>,
    // @@protoc_insertion_point(field:CGameRecording_GetTimelinesForClip_Response.first_timeline_start_offset_ms)
    pub first_timeline_start_offset_ms: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_GetTimelinesForClip_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_GetTimelinesForClip_Response {
    fn default() -> &'a CGameRecording_GetTimelinesForClip_Response {
        <CGameRecording_GetTimelinesForClip_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_GetTimelinesForClip_Response {
    pub fn new() -> CGameRecording_GetTimelinesForClip_Response {
        ::std::default::Default::default()
    }

    // optional uint64 game_id = 1;

    pub fn game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    // optional uint64 first_timeline_start_offset_ms = 3;

    pub fn first_timeline_start_offset_ms(&self) -> u64 {
        self.first_timeline_start_offset_ms.unwrap_or(0)
    }

    pub fn clear_first_timeline_start_offset_ms(&mut self) {
        self.first_timeline_start_offset_ms = ::std::option::Option::None;
    }

    pub fn has_first_timeline_start_offset_ms(&self) -> bool {
        self.first_timeline_start_offset_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_timeline_start_offset_ms(&mut self, v: u64) {
        self.first_timeline_start_offset_ms = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_GetTimelinesForClip_Response {
    const NAME: &'static str = "CGameRecording_GetTimelinesForClip_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.game_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.timelines.push(is.read_message()?);
                },
                24 => {
                    self.first_timeline_start_offset_ms = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.game_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        for value in &self.timelines {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.first_timeline_start_offset_ms {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.game_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.timelines {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.first_timeline_start_offset_ms {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_GetTimelinesForClip_Response {
        CGameRecording_GetTimelinesForClip_Response::new()
    }

    fn clear(&mut self) {
        self.game_id = ::std::option::Option::None;
        self.timelines.clear();
        self.first_timeline_start_offset_ms = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_GetTimelinesForClip_Response {
        static instance: CGameRecording_GetTimelinesForClip_Response = CGameRecording_GetTimelinesForClip_Response {
            game_id: ::std::option::Option::None,
            timelines: ::std::vec::Vec::new(),
            first_timeline_start_offset_ms: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_QueryPhases_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_QueryPhases_Request {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_QueryPhases_Request.page)
    pub page: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGameRecording_QueryPhases_Request.count)
    pub count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGameRecording_QueryPhases_Request.filter_gameid)
    pub filter_gameid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CGameRecording_QueryPhases_Request.filter_search_string)
    pub filter_search_string: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameRecording_QueryPhases_Request.filter_tags)
    pub filter_tags: ::std::vec::Vec<cgame_recording_query_phases_request::Tag>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_QueryPhases_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_QueryPhases_Request {
    fn default() -> &'a CGameRecording_QueryPhases_Request {
        <CGameRecording_QueryPhases_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_QueryPhases_Request {
    pub fn new() -> CGameRecording_QueryPhases_Request {
        ::std::default::Default::default()
    }

    // optional uint32 page = 1;

    pub fn page(&self) -> u32 {
        self.page.unwrap_or(0)
    }

    pub fn clear_page(&mut self) {
        self.page = ::std::option::Option::None;
    }

    pub fn has_page(&self) -> bool {
        self.page.is_some()
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = ::std::option::Option::Some(v);
    }

    // optional uint32 count = 2;

    pub fn count(&self) -> u32 {
        self.count.unwrap_or(0)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u32) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional uint64 filter_gameid = 10;

    pub fn filter_gameid(&self) -> u64 {
        self.filter_gameid.unwrap_or(0)
    }

    pub fn clear_filter_gameid(&mut self) {
        self.filter_gameid = ::std::option::Option::None;
    }

    pub fn has_filter_gameid(&self) -> bool {
        self.filter_gameid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter_gameid(&mut self, v: u64) {
        self.filter_gameid = ::std::option::Option::Some(v);
    }

    // optional string filter_search_string = 11;

    pub fn filter_search_string(&self) -> &str {
        match self.filter_search_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filter_search_string(&mut self) {
        self.filter_search_string = ::std::option::Option::None;
    }

    pub fn has_filter_search_string(&self) -> bool {
        self.filter_search_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter_search_string(&mut self, v: ::std::string::String) {
        self.filter_search_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter_search_string(&mut self) -> &mut ::std::string::String {
        if self.filter_search_string.is_none() {
            self.filter_search_string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.filter_search_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_filter_search_string(&mut self) -> ::std::string::String {
        self.filter_search_string.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_QueryPhases_Request {
    const NAME: &'static str = "CGameRecording_QueryPhases_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.page = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.count = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.filter_gameid = ::std::option::Option::Some(is.read_uint64()?);
                },
                90 => {
                    self.filter_search_string = ::std::option::Option::Some(is.read_string()?);
                },
                98 => {
                    self.filter_tags.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.page {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.filter_gameid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(10, v);
        }
        if let Some(v) = self.filter_search_string.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(11, &v);
        }
        for value in &self.filter_tags {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.page {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.count {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.filter_gameid {
            os.write_uint64(10, v)?;
        }
        if let Some(v) = self.filter_search_string.as_ref() {
            os.write_string(11, v)?;
        }
        for v in &self.filter_tags {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_QueryPhases_Request {
        CGameRecording_QueryPhases_Request::new()
    }

    fn clear(&mut self) {
        self.page = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.filter_gameid = ::std::option::Option::None;
        self.filter_search_string = ::std::option::Option::None;
        self.filter_tags.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_QueryPhases_Request {
        static instance: CGameRecording_QueryPhases_Request = CGameRecording_QueryPhases_Request {
            page: ::std::option::Option::None,
            count: ::std::option::Option::None,
            filter_gameid: ::std::option::Option::None,
            filter_search_string: ::std::option::Option::None,
            filter_tags: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CGameRecording_QueryPhases_Request`
pub mod cgame_recording_query_phases_request {
    // @@protoc_insertion_point(message:CGameRecording_QueryPhases_Request.Tag)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Tag {
        // message fields
        // @@protoc_insertion_point(field:CGameRecording_QueryPhases_Request.Tag.group)
        pub group: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CGameRecording_QueryPhases_Request.Tag.name)
        pub name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CGameRecording_QueryPhases_Request.Tag.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Tag {
        fn default() -> &'a Tag {
            <Tag as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Tag {
        pub fn new() -> Tag {
            ::std::default::Default::default()
        }

        // optional string group = 1;

        pub fn group(&self) -> &str {
            match self.group.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_group(&mut self) {
            self.group = ::std::option::Option::None;
        }

        pub fn has_group(&self) -> bool {
            self.group.is_some()
        }

        // Param is passed by value, moved
        pub fn set_group(&mut self, v: ::std::string::String) {
            self.group = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_group(&mut self) -> &mut ::std::string::String {
            if self.group.is_none() {
                self.group = ::std::option::Option::Some(::std::string::String::new());
            }
            self.group.as_mut().unwrap()
        }

        // Take field
        pub fn take_group(&mut self) -> ::std::string::String {
            self.group.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string name = 2;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Tag {
        const NAME: &'static str = "Tag";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.group = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.group.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.group.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Tag {
            Tag::new()
        }

        fn clear(&mut self) {
            self.group = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Tag {
            static instance: Tag = Tag {
                group: ::std::option::Option::None,
                name: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CGameRecording_QueryPhases_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_QueryPhases_Response {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_QueryPhases_Response.phases)
    pub phases: ::std::vec::Vec<cgame_recording_query_phases_response::Phase>,
    // @@protoc_insertion_point(field:CGameRecording_QueryPhases_Response.total_count)
    pub total_count: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_QueryPhases_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_QueryPhases_Response {
    fn default() -> &'a CGameRecording_QueryPhases_Response {
        <CGameRecording_QueryPhases_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_QueryPhases_Response {
    pub fn new() -> CGameRecording_QueryPhases_Response {
        ::std::default::Default::default()
    }

    // optional uint32 total_count = 2;

    pub fn total_count(&self) -> u32 {
        self.total_count.unwrap_or(0)
    }

    pub fn clear_total_count(&mut self) {
        self.total_count = ::std::option::Option::None;
    }

    pub fn has_total_count(&self) -> bool {
        self.total_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_count(&mut self, v: u32) {
        self.total_count = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_QueryPhases_Response {
    const NAME: &'static str = "CGameRecording_QueryPhases_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.phases.push(is.read_message()?);
                },
                16 => {
                    self.total_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.phases {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.total_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.phases {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.total_count {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_QueryPhases_Response {
        CGameRecording_QueryPhases_Response::new()
    }

    fn clear(&mut self) {
        self.phases.clear();
        self.total_count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_QueryPhases_Response {
        static instance: CGameRecording_QueryPhases_Response = CGameRecording_QueryPhases_Response {
            phases: ::std::vec::Vec::new(),
            total_count: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CGameRecording_QueryPhases_Response`
pub mod cgame_recording_query_phases_response {
    // @@protoc_insertion_point(message:CGameRecording_QueryPhases_Response.Phase)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Phase {
        // message fields
        // @@protoc_insertion_point(field:CGameRecording_QueryPhases_Response.Phase.game_id)
        pub game_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CGameRecording_QueryPhases_Response.Phase.title)
        pub title: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CGameRecording_QueryPhases_Response.Phase.desc)
        pub desc: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CGameRecording_QueryPhases_Response.Phase.icon)
        pub icon: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CGameRecording_QueryPhases_Response.Phase.date_recorded)
        pub date_recorded: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CGameRecording_QueryPhases_Response.Phase.duration_ms)
        pub duration_ms: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CGameRecording_QueryPhases_Response.Phase.tags)
        pub tags: ::std::vec::Vec<super::super::webuimessages_gamerecordingfiles::CTimelineTag>,
        // @@protoc_insertion_point(field:CGameRecording_QueryPhases_Response.Phase.contained_tags)
        pub contained_tags: ::std::vec::Vec<super::super::webuimessages_gamerecordingfiles::CTimelineTag>,
        // @@protoc_insertion_point(field:CGameRecording_QueryPhases_Response.Phase.background_recording)
        pub background_recording: ::steam_vent_proto_common::protobuf::MessageField<phase::BackgroundRecording>,
        // @@protoc_insertion_point(field:CGameRecording_QueryPhases_Response.Phase.clip_ids)
        pub clip_ids: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:CGameRecording_QueryPhases_Response.Phase.type)
        pub type_: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::EPhaseResultType>>,
        // @@protoc_insertion_point(field:CGameRecording_QueryPhases_Response.Phase.start_ms)
        pub start_ms: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CGameRecording_QueryPhases_Response.Phase.screenshots)
        pub screenshots: ::std::vec::Vec<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CGameRecording_QueryPhases_Response.Phase.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Phase {
        fn default() -> &'a Phase {
            <Phase as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Phase {
        pub fn new() -> Phase {
            ::std::default::Default::default()
        }

        // optional uint64 game_id = 1;

        pub fn game_id(&self) -> u64 {
            self.game_id.unwrap_or(0)
        }

        pub fn clear_game_id(&mut self) {
            self.game_id = ::std::option::Option::None;
        }

        pub fn has_game_id(&self) -> bool {
            self.game_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_id(&mut self, v: u64) {
            self.game_id = ::std::option::Option::Some(v);
        }

        // optional string title = 2;

        pub fn title(&self) -> &str {
            match self.title.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_title(&mut self) {
            self.title = ::std::option::Option::None;
        }

        pub fn has_title(&self) -> bool {
            self.title.is_some()
        }

        // Param is passed by value, moved
        pub fn set_title(&mut self, v: ::std::string::String) {
            self.title = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_title(&mut self) -> &mut ::std::string::String {
            if self.title.is_none() {
                self.title = ::std::option::Option::Some(::std::string::String::new());
            }
            self.title.as_mut().unwrap()
        }

        // Take field
        pub fn take_title(&mut self) -> ::std::string::String {
            self.title.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string desc = 3;

        pub fn desc(&self) -> &str {
            match self.desc.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_desc(&mut self) {
            self.desc = ::std::option::Option::None;
        }

        pub fn has_desc(&self) -> bool {
            self.desc.is_some()
        }

        // Param is passed by value, moved
        pub fn set_desc(&mut self, v: ::std::string::String) {
            self.desc = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_desc(&mut self) -> &mut ::std::string::String {
            if self.desc.is_none() {
                self.desc = ::std::option::Option::Some(::std::string::String::new());
            }
            self.desc.as_mut().unwrap()
        }

        // Take field
        pub fn take_desc(&mut self) -> ::std::string::String {
            self.desc.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string icon = 4;

        pub fn icon(&self) -> &str {
            match self.icon.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_icon(&mut self) {
            self.icon = ::std::option::Option::None;
        }

        pub fn has_icon(&self) -> bool {
            self.icon.is_some()
        }

        // Param is passed by value, moved
        pub fn set_icon(&mut self, v: ::std::string::String) {
            self.icon = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_icon(&mut self) -> &mut ::std::string::String {
            if self.icon.is_none() {
                self.icon = ::std::option::Option::Some(::std::string::String::new());
            }
            self.icon.as_mut().unwrap()
        }

        // Take field
        pub fn take_icon(&mut self) -> ::std::string::String {
            self.icon.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 date_recorded = 5;

        pub fn date_recorded(&self) -> u32 {
            self.date_recorded.unwrap_or(0)
        }

        pub fn clear_date_recorded(&mut self) {
            self.date_recorded = ::std::option::Option::None;
        }

        pub fn has_date_recorded(&self) -> bool {
            self.date_recorded.is_some()
        }

        // Param is passed by value, moved
        pub fn set_date_recorded(&mut self, v: u32) {
            self.date_recorded = ::std::option::Option::Some(v);
        }

        // optional uint64 duration_ms = 6;

        pub fn duration_ms(&self) -> u64 {
            self.duration_ms.unwrap_or(0)
        }

        pub fn clear_duration_ms(&mut self) {
            self.duration_ms = ::std::option::Option::None;
        }

        pub fn has_duration_ms(&self) -> bool {
            self.duration_ms.is_some()
        }

        // Param is passed by value, moved
        pub fn set_duration_ms(&mut self, v: u64) {
            self.duration_ms = ::std::option::Option::Some(v);
        }

        // optional .EPhaseResultType type = 11;

        pub fn type_(&self) -> super::EPhaseResultType {
            match self.type_ {
                Some(e) => e.enum_value_or(super::EPhaseResultType::k_EPhaseResultType_Automatic),
                None => super::EPhaseResultType::k_EPhaseResultType_Automatic,
            }
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: super::EPhaseResultType) {
            self.type_ = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }

        // optional uint64 start_ms = 12;

        pub fn start_ms(&self) -> u64 {
            self.start_ms.unwrap_or(0)
        }

        pub fn clear_start_ms(&mut self) {
            self.start_ms = ::std::option::Option::None;
        }

        pub fn has_start_ms(&self) -> bool {
            self.start_ms.is_some()
        }

        // Param is passed by value, moved
        pub fn set_start_ms(&mut self, v: u64) {
            self.start_ms = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Phase {
        const NAME: &'static str = "Phase";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.game_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    18 => {
                        self.title = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.desc = ::std::option::Option::Some(is.read_string()?);
                    },
                    34 => {
                        self.icon = ::std::option::Option::Some(is.read_string()?);
                    },
                    40 => {
                        self.date_recorded = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.duration_ms = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    58 => {
                        self.tags.push(is.read_message()?);
                    },
                    66 => {
                        self.contained_tags.push(is.read_message()?);
                    },
                    74 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.background_recording)?;
                    },
                    82 => {
                        self.clip_ids.push(is.read_string()?);
                    },
                    88 => {
                        self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    96 => {
                        self.start_ms = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    106 => {
                        is.read_repeated_packed_uint32_into(&mut self.screenshots)?;
                    },
                    104 => {
                        self.screenshots.push(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.game_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.title.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.desc.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.icon.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
            }
            if let Some(v) = self.date_recorded {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.duration_ms {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(6, v);
            }
            for value in &self.tags {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.contained_tags {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.background_recording.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            for value in &self.clip_ids {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(10, &value);
            };
            if let Some(v) = self.type_ {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(11, v.value());
            }
            if let Some(v) = self.start_ms {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(12, v);
            }
            for value in &self.screenshots {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(13, *value);
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.game_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.title.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.desc.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.icon.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.date_recorded {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.duration_ms {
                os.write_uint64(6, v)?;
            }
            for v in &self.tags {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
            };
            for v in &self.contained_tags {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
            };
            if let Some(v) = self.background_recording.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
            }
            for v in &self.clip_ids {
                os.write_string(10, &v)?;
            };
            if let Some(v) = self.type_ {
                os.write_enum(11, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.start_ms {
                os.write_uint64(12, v)?;
            }
            for v in &self.screenshots {
                os.write_uint32(13, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Phase {
            Phase::new()
        }

        fn clear(&mut self) {
            self.game_id = ::std::option::Option::None;
            self.title = ::std::option::Option::None;
            self.desc = ::std::option::Option::None;
            self.icon = ::std::option::Option::None;
            self.date_recorded = ::std::option::Option::None;
            self.duration_ms = ::std::option::Option::None;
            self.tags.clear();
            self.contained_tags.clear();
            self.background_recording.clear();
            self.clip_ids.clear();
            self.type_ = ::std::option::Option::None;
            self.start_ms = ::std::option::Option::None;
            self.screenshots.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Phase {
            static instance: Phase = Phase {
                game_id: ::std::option::Option::None,
                title: ::std::option::Option::None,
                desc: ::std::option::Option::None,
                icon: ::std::option::Option::None,
                date_recorded: ::std::option::Option::None,
                duration_ms: ::std::option::Option::None,
                tags: ::std::vec::Vec::new(),
                contained_tags: ::std::vec::Vec::new(),
                background_recording: ::steam_vent_proto_common::protobuf::MessageField::none(),
                clip_ids: ::std::vec::Vec::new(),
                type_: ::std::option::Option::None,
                start_ms: ::std::option::Option::None,
                screenshots: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `Phase`
    pub mod phase {
        // @@protoc_insertion_point(message:CGameRecording_QueryPhases_Response.Phase.BackgroundRecording)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct BackgroundRecording {
            // message fields
            // @@protoc_insertion_point(field:CGameRecording_QueryPhases_Response.Phase.BackgroundRecording.timeline_id)
            pub timeline_id: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:CGameRecording_QueryPhases_Response.Phase.BackgroundRecording.offset)
            pub offset: ::std::option::Option<u64>,
            // @@protoc_insertion_point(field:CGameRecording_QueryPhases_Response.Phase.BackgroundRecording.duration_ms)
            pub duration_ms: ::std::option::Option<u64>,
            // special fields
            // @@protoc_insertion_point(special_field:CGameRecording_QueryPhases_Response.Phase.BackgroundRecording.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a BackgroundRecording {
            fn default() -> &'a BackgroundRecording {
                <BackgroundRecording as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl BackgroundRecording {
            pub fn new() -> BackgroundRecording {
                ::std::default::Default::default()
            }

            // optional string timeline_id = 1;

            pub fn timeline_id(&self) -> &str {
                match self.timeline_id.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_timeline_id(&mut self) {
                self.timeline_id = ::std::option::Option::None;
            }

            pub fn has_timeline_id(&self) -> bool {
                self.timeline_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_timeline_id(&mut self, v: ::std::string::String) {
                self.timeline_id = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_timeline_id(&mut self) -> &mut ::std::string::String {
                if self.timeline_id.is_none() {
                    self.timeline_id = ::std::option::Option::Some(::std::string::String::new());
                }
                self.timeline_id.as_mut().unwrap()
            }

            // Take field
            pub fn take_timeline_id(&mut self) -> ::std::string::String {
                self.timeline_id.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional uint64 offset = 2;

            pub fn offset(&self) -> u64 {
                self.offset.unwrap_or(0)
            }

            pub fn clear_offset(&mut self) {
                self.offset = ::std::option::Option::None;
            }

            pub fn has_offset(&self) -> bool {
                self.offset.is_some()
            }

            // Param is passed by value, moved
            pub fn set_offset(&mut self, v: u64) {
                self.offset = ::std::option::Option::Some(v);
            }

            // optional uint64 duration_ms = 3;

            pub fn duration_ms(&self) -> u64 {
                self.duration_ms.unwrap_or(0)
            }

            pub fn clear_duration_ms(&mut self) {
                self.duration_ms = ::std::option::Option::None;
            }

            pub fn has_duration_ms(&self) -> bool {
                self.duration_ms.is_some()
            }

            // Param is passed by value, moved
            pub fn set_duration_ms(&mut self, v: u64) {
                self.duration_ms = ::std::option::Option::Some(v);
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for BackgroundRecording {
            const NAME: &'static str = "BackgroundRecording";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.timeline_id = ::std::option::Option::Some(is.read_string()?);
                        },
                        16 => {
                            self.offset = ::std::option::Option::Some(is.read_uint64()?);
                        },
                        24 => {
                            self.duration_ms = ::std::option::Option::Some(is.read_uint64()?);
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.timeline_id.as_ref() {
                    my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
                }
                if let Some(v) = self.offset {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
                }
                if let Some(v) = self.duration_ms {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
                }
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                if let Some(v) = self.timeline_id.as_ref() {
                    os.write_string(1, v)?;
                }
                if let Some(v) = self.offset {
                    os.write_uint64(2, v)?;
                }
                if let Some(v) = self.duration_ms {
                    os.write_uint64(3, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> BackgroundRecording {
                BackgroundRecording::new()
            }

            fn clear(&mut self) {
                self.timeline_id = ::std::option::Option::None;
                self.offset = ::std::option::Option::None;
                self.duration_ms = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static BackgroundRecording {
                static instance: BackgroundRecording = BackgroundRecording {
                    timeline_id: ::std::option::Option::None,
                    offset: ::std::option::Option::None,
                    duration_ms: ::std::option::Option::None,
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }
    }
}

// @@protoc_insertion_point(message:CGameRecording_GetTags_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_GetTags_Request {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_GetTags_Request.game_id)
    pub game_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_GetTags_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_GetTags_Request {
    fn default() -> &'a CGameRecording_GetTags_Request {
        <CGameRecording_GetTags_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_GetTags_Request {
    pub fn new() -> CGameRecording_GetTags_Request {
        ::std::default::Default::default()
    }

    // optional uint64 game_id = 1;

    pub fn game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_GetTags_Request {
    const NAME: &'static str = "CGameRecording_GetTags_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.game_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.game_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.game_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_GetTags_Request {
        CGameRecording_GetTags_Request::new()
    }

    fn clear(&mut self) {
        self.game_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_GetTags_Request {
        static instance: CGameRecording_GetTags_Request = CGameRecording_GetTags_Request {
            game_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_GetTags_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_GetTags_Response {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_GetTags_Response.tags)
    pub tags: ::std::vec::Vec<super::webuimessages_gamerecordingfiles::CTimelineTag>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_GetTags_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_GetTags_Response {
    fn default() -> &'a CGameRecording_GetTags_Response {
        <CGameRecording_GetTags_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_GetTags_Response {
    pub fn new() -> CGameRecording_GetTags_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_GetTags_Response {
    const NAME: &'static str = "CGameRecording_GetTags_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.tags.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.tags {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.tags {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_GetTags_Response {
        CGameRecording_GetTags_Response::new()
    }

    fn clear(&mut self) {
        self.tags.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_GetTags_Response {
        static instance: CGameRecording_GetTags_Response = CGameRecording_GetTags_Response {
            tags: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_GetEnoughDiskSpace_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_GetEnoughDiskSpace_Request {
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_GetEnoughDiskSpace_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_GetEnoughDiskSpace_Request {
    fn default() -> &'a CGameRecording_GetEnoughDiskSpace_Request {
        <CGameRecording_GetEnoughDiskSpace_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_GetEnoughDiskSpace_Request {
    pub fn new() -> CGameRecording_GetEnoughDiskSpace_Request {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_GetEnoughDiskSpace_Request {
    const NAME: &'static str = "CGameRecording_GetEnoughDiskSpace_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_GetEnoughDiskSpace_Request {
        CGameRecording_GetEnoughDiskSpace_Request::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_GetEnoughDiskSpace_Request {
        static instance: CGameRecording_GetEnoughDiskSpace_Request = CGameRecording_GetEnoughDiskSpace_Request {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_GetEnoughDiskSpace_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_GetEnoughDiskSpace_Response {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_GetEnoughDiskSpace_Response.enough_space)
    pub enough_space: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_GetEnoughDiskSpace_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_GetEnoughDiskSpace_Response {
    fn default() -> &'a CGameRecording_GetEnoughDiskSpace_Response {
        <CGameRecording_GetEnoughDiskSpace_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_GetEnoughDiskSpace_Response {
    pub fn new() -> CGameRecording_GetEnoughDiskSpace_Response {
        ::std::default::Default::default()
    }

    // optional bool enough_space = 1;

    pub fn enough_space(&self) -> bool {
        self.enough_space.unwrap_or(false)
    }

    pub fn clear_enough_space(&mut self) {
        self.enough_space = ::std::option::Option::None;
    }

    pub fn has_enough_space(&self) -> bool {
        self.enough_space.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enough_space(&mut self, v: bool) {
        self.enough_space = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_GetEnoughDiskSpace_Response {
    const NAME: &'static str = "CGameRecording_GetEnoughDiskSpace_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.enough_space = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.enough_space {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.enough_space {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_GetEnoughDiskSpace_Response {
        CGameRecording_GetEnoughDiskSpace_Response::new()
    }

    fn clear(&mut self) {
        self.enough_space = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_GetEnoughDiskSpace_Response {
        static instance: CGameRecording_GetEnoughDiskSpace_Response = CGameRecording_GetEnoughDiskSpace_Response {
            enough_space: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_GetAvailableDiskSpace_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_GetAvailableDiskSpace_Request {
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_GetAvailableDiskSpace_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_GetAvailableDiskSpace_Request {
    fn default() -> &'a CGameRecording_GetAvailableDiskSpace_Request {
        <CGameRecording_GetAvailableDiskSpace_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_GetAvailableDiskSpace_Request {
    pub fn new() -> CGameRecording_GetAvailableDiskSpace_Request {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_GetAvailableDiskSpace_Request {
    const NAME: &'static str = "CGameRecording_GetAvailableDiskSpace_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_GetAvailableDiskSpace_Request {
        CGameRecording_GetAvailableDiskSpace_Request::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_GetAvailableDiskSpace_Request {
        static instance: CGameRecording_GetAvailableDiskSpace_Request = CGameRecording_GetAvailableDiskSpace_Request {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_GetAvailableDiskSpace_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_GetAvailableDiskSpace_Response {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_GetAvailableDiskSpace_Response.size)
    pub size: ::std::option::Option<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_GetAvailableDiskSpace_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_GetAvailableDiskSpace_Response {
    fn default() -> &'a CGameRecording_GetAvailableDiskSpace_Response {
        <CGameRecording_GetAvailableDiskSpace_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_GetAvailableDiskSpace_Response {
    pub fn new() -> CGameRecording_GetAvailableDiskSpace_Response {
        ::std::default::Default::default()
    }

    // optional double size = 1;

    pub fn size(&self) -> f64 {
        self.size.unwrap_or(0.)
    }

    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: f64) {
        self.size = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_GetAvailableDiskSpace_Response {
    const NAME: &'static str = "CGameRecording_GetAvailableDiskSpace_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.size = ::std::option::Option::Some(is.read_double()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.size {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.size {
            os.write_double(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_GetAvailableDiskSpace_Response {
        CGameRecording_GetAvailableDiskSpace_Response::new()
    }

    fn clear(&mut self) {
        self.size = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_GetAvailableDiskSpace_Response {
        static instance: CGameRecording_GetAvailableDiskSpace_Response = CGameRecording_GetAvailableDiskSpace_Response {
            size: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_TimelineChanged_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_TimelineChanged_Notification {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_TimelineChanged_Notification.notification_type)
    pub notification_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<ETimelineChangeNotificationType>>,
    // @@protoc_insertion_point(field:CGameRecording_TimelineChanged_Notification.timeline_id)
    pub timeline_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameRecording_TimelineChanged_Notification.game_id)
    pub game_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CGameRecording_TimelineChanged_Notification.start_time)
    pub start_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGameRecording_TimelineChanged_Notification.duration_ms)
    pub duration_ms: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_TimelineChanged_Notification.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_TimelineChanged_Notification {
    fn default() -> &'a CGameRecording_TimelineChanged_Notification {
        <CGameRecording_TimelineChanged_Notification as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_TimelineChanged_Notification {
    pub fn new() -> CGameRecording_TimelineChanged_Notification {
        ::std::default::Default::default()
    }

    // optional .ETimelineChangeNotificationType notification_type = 1;

    pub fn notification_type(&self) -> ETimelineChangeNotificationType {
        match self.notification_type {
            Some(e) => e.enum_value_or(ETimelineChangeNotificationType::k_ETimelineChangeNotificationType_Started),
            None => ETimelineChangeNotificationType::k_ETimelineChangeNotificationType_Started,
        }
    }

    pub fn clear_notification_type(&mut self) {
        self.notification_type = ::std::option::Option::None;
    }

    pub fn has_notification_type(&self) -> bool {
        self.notification_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notification_type(&mut self, v: ETimelineChangeNotificationType) {
        self.notification_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional string timeline_id = 2;

    pub fn timeline_id(&self) -> &str {
        match self.timeline_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_timeline_id(&mut self) {
        self.timeline_id = ::std::option::Option::None;
    }

    pub fn has_timeline_id(&self) -> bool {
        self.timeline_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeline_id(&mut self, v: ::std::string::String) {
        self.timeline_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_timeline_id(&mut self) -> &mut ::std::string::String {
        if self.timeline_id.is_none() {
            self.timeline_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.timeline_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_timeline_id(&mut self) -> ::std::string::String {
        self.timeline_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 game_id = 3;

    pub fn game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    // optional uint32 start_time = 4;

    pub fn start_time(&self) -> u32 {
        self.start_time.unwrap_or(0)
    }

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: u32) {
        self.start_time = ::std::option::Option::Some(v);
    }

    // optional uint64 duration_ms = 5;

    pub fn duration_ms(&self) -> u64 {
        self.duration_ms.unwrap_or(0)
    }

    pub fn clear_duration_ms(&mut self) {
        self.duration_ms = ::std::option::Option::None;
    }

    pub fn has_duration_ms(&self) -> bool {
        self.duration_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration_ms(&mut self, v: u64) {
        self.duration_ms = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_TimelineChanged_Notification {
    const NAME: &'static str = "CGameRecording_TimelineChanged_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.notification_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.timeline_id = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.game_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.start_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.duration_ms = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.notification_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.timeline_id.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.game_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.start_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.duration_ms {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(5, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.notification_type {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.timeline_id.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.game_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.start_time {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.duration_ms {
            os.write_uint64(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_TimelineChanged_Notification {
        CGameRecording_TimelineChanged_Notification::new()
    }

    fn clear(&mut self) {
        self.notification_type = ::std::option::Option::None;
        self.timeline_id = ::std::option::Option::None;
        self.game_id = ::std::option::Option::None;
        self.start_time = ::std::option::Option::None;
        self.duration_ms = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_TimelineChanged_Notification {
        static instance: CGameRecording_TimelineChanged_Notification = CGameRecording_TimelineChanged_Notification {
            notification_type: ::std::option::Option::None,
            timeline_id: ::std::option::Option::None,
            game_id: ::std::option::Option::None,
            start_time: ::std::option::Option::None,
            duration_ms: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_RecordingSessionChanged_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_RecordingSessionChanged_Notification {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_RecordingSessionChanged_Notification.notification_type)
    pub notification_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<ERecordingSessionChangeNotificationType>>,
    // @@protoc_insertion_point(field:CGameRecording_RecordingSessionChanged_Notification.timeline_id)
    pub timeline_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameRecording_RecordingSessionChanged_Notification.game_id)
    pub game_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CGameRecording_RecordingSessionChanged_Notification.session_id)
    pub session_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameRecording_RecordingSessionChanged_Notification.start_offset)
    pub start_offset: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CGameRecording_RecordingSessionChanged_Notification.duration_ms)
    pub duration_ms: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CGameRecording_RecordingSessionChanged_Notification.recording_type)
    pub recording_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::enums::EGameRecordingType>>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_RecordingSessionChanged_Notification.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_RecordingSessionChanged_Notification {
    fn default() -> &'a CGameRecording_RecordingSessionChanged_Notification {
        <CGameRecording_RecordingSessionChanged_Notification as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_RecordingSessionChanged_Notification {
    pub fn new() -> CGameRecording_RecordingSessionChanged_Notification {
        ::std::default::Default::default()
    }

    // optional .ERecordingSessionChangeNotificationType notification_type = 1;

    pub fn notification_type(&self) -> ERecordingSessionChangeNotificationType {
        match self.notification_type {
            Some(e) => e.enum_value_or(ERecordingSessionChangeNotificationType::k_ERecordingSessionChangeNotificationType_Started),
            None => ERecordingSessionChangeNotificationType::k_ERecordingSessionChangeNotificationType_Started,
        }
    }

    pub fn clear_notification_type(&mut self) {
        self.notification_type = ::std::option::Option::None;
    }

    pub fn has_notification_type(&self) -> bool {
        self.notification_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notification_type(&mut self, v: ERecordingSessionChangeNotificationType) {
        self.notification_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional string timeline_id = 2;

    pub fn timeline_id(&self) -> &str {
        match self.timeline_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_timeline_id(&mut self) {
        self.timeline_id = ::std::option::Option::None;
    }

    pub fn has_timeline_id(&self) -> bool {
        self.timeline_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeline_id(&mut self, v: ::std::string::String) {
        self.timeline_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_timeline_id(&mut self) -> &mut ::std::string::String {
        if self.timeline_id.is_none() {
            self.timeline_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.timeline_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_timeline_id(&mut self) -> ::std::string::String {
        self.timeline_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 game_id = 4;

    pub fn game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    // optional string session_id = 5;

    pub fn session_id(&self) -> &str {
        match self.session_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_session_id(&mut self) {
        self.session_id = ::std::option::Option::None;
    }

    pub fn has_session_id(&self) -> bool {
        self.session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_id(&mut self, v: ::std::string::String) {
        self.session_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_session_id(&mut self) -> &mut ::std::string::String {
        if self.session_id.is_none() {
            self.session_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.session_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_session_id(&mut self) -> ::std::string::String {
        self.session_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 start_offset = 6;

    pub fn start_offset(&self) -> u64 {
        self.start_offset.unwrap_or(0)
    }

    pub fn clear_start_offset(&mut self) {
        self.start_offset = ::std::option::Option::None;
    }

    pub fn has_start_offset(&self) -> bool {
        self.start_offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_offset(&mut self, v: u64) {
        self.start_offset = ::std::option::Option::Some(v);
    }

    // optional uint64 duration_ms = 7;

    pub fn duration_ms(&self) -> u64 {
        self.duration_ms.unwrap_or(0)
    }

    pub fn clear_duration_ms(&mut self) {
        self.duration_ms = ::std::option::Option::None;
    }

    pub fn has_duration_ms(&self) -> bool {
        self.duration_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration_ms(&mut self, v: u64) {
        self.duration_ms = ::std::option::Option::Some(v);
    }

    // optional .EGameRecordingType recording_type = 8;

    pub fn recording_type(&self) -> super::enums::EGameRecordingType {
        match self.recording_type {
            Some(e) => e.enum_value_or(super::enums::EGameRecordingType::k_EGameRecordingType_Unknown),
            None => super::enums::EGameRecordingType::k_EGameRecordingType_Unknown,
        }
    }

    pub fn clear_recording_type(&mut self) {
        self.recording_type = ::std::option::Option::None;
    }

    pub fn has_recording_type(&self) -> bool {
        self.recording_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recording_type(&mut self, v: super::enums::EGameRecordingType) {
        self.recording_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_RecordingSessionChanged_Notification {
    const NAME: &'static str = "CGameRecording_RecordingSessionChanged_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.notification_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.timeline_id = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.game_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                42 => {
                    self.session_id = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.start_offset = ::std::option::Option::Some(is.read_uint64()?);
                },
                56 => {
                    self.duration_ms = ::std::option::Option::Some(is.read_uint64()?);
                },
                64 => {
                    self.recording_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.notification_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.timeline_id.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.game_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.session_id.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.start_offset {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(6, v);
        }
        if let Some(v) = self.duration_ms {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(7, v);
        }
        if let Some(v) = self.recording_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(8, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.notification_type {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.timeline_id.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.game_id {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.session_id.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.start_offset {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.duration_ms {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.recording_type {
            os.write_enum(8, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_RecordingSessionChanged_Notification {
        CGameRecording_RecordingSessionChanged_Notification::new()
    }

    fn clear(&mut self) {
        self.notification_type = ::std::option::Option::None;
        self.timeline_id = ::std::option::Option::None;
        self.game_id = ::std::option::Option::None;
        self.session_id = ::std::option::Option::None;
        self.start_offset = ::std::option::Option::None;
        self.duration_ms = ::std::option::Option::None;
        self.recording_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_RecordingSessionChanged_Notification {
        static instance: CGameRecording_RecordingSessionChanged_Notification = CGameRecording_RecordingSessionChanged_Notification {
            notification_type: ::std::option::Option::None,
            timeline_id: ::std::option::Option::None,
            game_id: ::std::option::Option::None,
            session_id: ::std::option::Option::None,
            start_offset: ::std::option::Option::None,
            duration_ms: ::std::option::Option::None,
            recording_type: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CTimelineEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CTimelineEntry {
    // message fields
    // @@protoc_insertion_point(field:CTimelineEntry.timeline_id)
    pub timeline_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CTimelineEntry.entry_id)
    pub entry_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CTimelineEntry.time)
    pub time: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CTimelineEntry.type)
    pub type_: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<ETimelineEntryType>>,
    // @@protoc_insertion_point(field:CTimelineEntry.game_mode)
    pub game_mode: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CTimelineEntry.range_title)
    pub range_title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CTimelineEntry.range_duration)
    pub range_duration: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CTimelineEntry.range_possible_clip)
    pub range_possible_clip: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CTimelineEntry.timestamp_title)
    pub timestamp_title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CTimelineEntry.marker_icon)
    pub marker_icon: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CTimelineEntry.marker_description)
    pub marker_description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CTimelineEntry.marker_priority)
    pub marker_priority: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CTimelineEntry.screenshot_handle)
    pub screenshot_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CTimelineEntry.achievement_name)
    pub achievement_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CTimelineEntry.tag)
    pub tag: ::std::vec::Vec<super::webuimessages_gamerecordingfiles::CTimelineTag>,
    // @@protoc_insertion_point(field:CTimelineEntry.phase_id)
    pub phase_id: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CTimelineEntry.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CTimelineEntry {
    fn default() -> &'a CTimelineEntry {
        <CTimelineEntry as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CTimelineEntry {
    pub fn new() -> CTimelineEntry {
        ::std::default::Default::default()
    }

    // optional string timeline_id = 1;

    pub fn timeline_id(&self) -> &str {
        match self.timeline_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_timeline_id(&mut self) {
        self.timeline_id = ::std::option::Option::None;
    }

    pub fn has_timeline_id(&self) -> bool {
        self.timeline_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeline_id(&mut self, v: ::std::string::String) {
        self.timeline_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_timeline_id(&mut self) -> &mut ::std::string::String {
        if self.timeline_id.is_none() {
            self.timeline_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.timeline_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_timeline_id(&mut self) -> ::std::string::String {
        self.timeline_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 entry_id = 2;

    pub fn entry_id(&self) -> u64 {
        self.entry_id.unwrap_or(0)
    }

    pub fn clear_entry_id(&mut self) {
        self.entry_id = ::std::option::Option::None;
    }

    pub fn has_entry_id(&self) -> bool {
        self.entry_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entry_id(&mut self, v: u64) {
        self.entry_id = ::std::option::Option::Some(v);
    }

    // optional uint64 time = 3;

    pub fn time(&self) -> u64 {
        self.time.unwrap_or(0)
    }

    pub fn clear_time(&mut self) {
        self.time = ::std::option::Option::None;
    }

    pub fn has_time(&self) -> bool {
        self.time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: u64) {
        self.time = ::std::option::Option::Some(v);
    }

    // optional .ETimelineEntryType type = 4;

    pub fn type_(&self) -> ETimelineEntryType {
        match self.type_ {
            Some(e) => e.enum_value_or(ETimelineEntryType::k_ETimelineEntryType_Invalid),
            None => ETimelineEntryType::k_ETimelineEntryType_Invalid,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ETimelineEntryType) {
        self.type_ = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 game_mode = 5;

    pub fn game_mode(&self) -> i32 {
        self.game_mode.unwrap_or(0)
    }

    pub fn clear_game_mode(&mut self) {
        self.game_mode = ::std::option::Option::None;
    }

    pub fn has_game_mode(&self) -> bool {
        self.game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mode(&mut self, v: i32) {
        self.game_mode = ::std::option::Option::Some(v);
    }

    // optional string range_title = 7;

    pub fn range_title(&self) -> &str {
        match self.range_title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_range_title(&mut self) {
        self.range_title = ::std::option::Option::None;
    }

    pub fn has_range_title(&self) -> bool {
        self.range_title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_range_title(&mut self, v: ::std::string::String) {
        self.range_title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_range_title(&mut self) -> &mut ::std::string::String {
        if self.range_title.is_none() {
            self.range_title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.range_title.as_mut().unwrap()
    }

    // Take field
    pub fn take_range_title(&mut self) -> ::std::string::String {
        self.range_title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 range_duration = 8;

    pub fn range_duration(&self) -> u64 {
        self.range_duration.unwrap_or(0)
    }

    pub fn clear_range_duration(&mut self) {
        self.range_duration = ::std::option::Option::None;
    }

    pub fn has_range_duration(&self) -> bool {
        self.range_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_range_duration(&mut self, v: u64) {
        self.range_duration = ::std::option::Option::Some(v);
    }

    // optional int32 range_possible_clip = 9;

    pub fn range_possible_clip(&self) -> i32 {
        self.range_possible_clip.unwrap_or(0)
    }

    pub fn clear_range_possible_clip(&mut self) {
        self.range_possible_clip = ::std::option::Option::None;
    }

    pub fn has_range_possible_clip(&self) -> bool {
        self.range_possible_clip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_range_possible_clip(&mut self, v: i32) {
        self.range_possible_clip = ::std::option::Option::Some(v);
    }

    // optional string timestamp_title = 10;

    pub fn timestamp_title(&self) -> &str {
        match self.timestamp_title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_timestamp_title(&mut self) {
        self.timestamp_title = ::std::option::Option::None;
    }

    pub fn has_timestamp_title(&self) -> bool {
        self.timestamp_title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp_title(&mut self, v: ::std::string::String) {
        self.timestamp_title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_timestamp_title(&mut self) -> &mut ::std::string::String {
        if self.timestamp_title.is_none() {
            self.timestamp_title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.timestamp_title.as_mut().unwrap()
    }

    // Take field
    pub fn take_timestamp_title(&mut self) -> ::std::string::String {
        self.timestamp_title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string marker_icon = 11;

    pub fn marker_icon(&self) -> &str {
        match self.marker_icon.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_marker_icon(&mut self) {
        self.marker_icon = ::std::option::Option::None;
    }

    pub fn has_marker_icon(&self) -> bool {
        self.marker_icon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_marker_icon(&mut self, v: ::std::string::String) {
        self.marker_icon = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_marker_icon(&mut self) -> &mut ::std::string::String {
        if self.marker_icon.is_none() {
            self.marker_icon = ::std::option::Option::Some(::std::string::String::new());
        }
        self.marker_icon.as_mut().unwrap()
    }

    // Take field
    pub fn take_marker_icon(&mut self) -> ::std::string::String {
        self.marker_icon.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string marker_description = 13;

    pub fn marker_description(&self) -> &str {
        match self.marker_description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_marker_description(&mut self) {
        self.marker_description = ::std::option::Option::None;
    }

    pub fn has_marker_description(&self) -> bool {
        self.marker_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_marker_description(&mut self, v: ::std::string::String) {
        self.marker_description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_marker_description(&mut self) -> &mut ::std::string::String {
        if self.marker_description.is_none() {
            self.marker_description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.marker_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_marker_description(&mut self) -> ::std::string::String {
        self.marker_description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 marker_priority = 14;

    pub fn marker_priority(&self) -> i32 {
        self.marker_priority.unwrap_or(0)
    }

    pub fn clear_marker_priority(&mut self) {
        self.marker_priority = ::std::option::Option::None;
    }

    pub fn has_marker_priority(&self) -> bool {
        self.marker_priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_marker_priority(&mut self, v: i32) {
        self.marker_priority = ::std::option::Option::Some(v);
    }

    // optional uint32 screenshot_handle = 15;

    pub fn screenshot_handle(&self) -> u32 {
        self.screenshot_handle.unwrap_or(0)
    }

    pub fn clear_screenshot_handle(&mut self) {
        self.screenshot_handle = ::std::option::Option::None;
    }

    pub fn has_screenshot_handle(&self) -> bool {
        self.screenshot_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_screenshot_handle(&mut self, v: u32) {
        self.screenshot_handle = ::std::option::Option::Some(v);
    }

    // optional string achievement_name = 16;

    pub fn achievement_name(&self) -> &str {
        match self.achievement_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_achievement_name(&mut self) {
        self.achievement_name = ::std::option::Option::None;
    }

    pub fn has_achievement_name(&self) -> bool {
        self.achievement_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_achievement_name(&mut self, v: ::std::string::String) {
        self.achievement_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_achievement_name(&mut self) -> &mut ::std::string::String {
        if self.achievement_name.is_none() {
            self.achievement_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.achievement_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_achievement_name(&mut self) -> ::std::string::String {
        self.achievement_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string phase_id = 18;

    pub fn phase_id(&self) -> &str {
        match self.phase_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_phase_id(&mut self) {
        self.phase_id = ::std::option::Option::None;
    }

    pub fn has_phase_id(&self) -> bool {
        self.phase_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phase_id(&mut self, v: ::std::string::String) {
        self.phase_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phase_id(&mut self) -> &mut ::std::string::String {
        if self.phase_id.is_none() {
            self.phase_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.phase_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_phase_id(&mut self) -> ::std::string::String {
        self.phase_id.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CTimelineEntry {
    const NAME: &'static str = "CTimelineEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.timeline_id = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.entry_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.time = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.game_mode = ::std::option::Option::Some(is.read_int32()?);
                },
                58 => {
                    self.range_title = ::std::option::Option::Some(is.read_string()?);
                },
                64 => {
                    self.range_duration = ::std::option::Option::Some(is.read_uint64()?);
                },
                72 => {
                    self.range_possible_clip = ::std::option::Option::Some(is.read_int32()?);
                },
                82 => {
                    self.timestamp_title = ::std::option::Option::Some(is.read_string()?);
                },
                90 => {
                    self.marker_icon = ::std::option::Option::Some(is.read_string()?);
                },
                106 => {
                    self.marker_description = ::std::option::Option::Some(is.read_string()?);
                },
                112 => {
                    self.marker_priority = ::std::option::Option::Some(is.read_int32()?);
                },
                120 => {
                    self.screenshot_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                130 => {
                    self.achievement_name = ::std::option::Option::Some(is.read_string()?);
                },
                138 => {
                    self.tag.push(is.read_message()?);
                },
                146 => {
                    self.phase_id = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.timeline_id.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.entry_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.type_ {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.game_mode {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.range_title.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.range_duration {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(8, v);
        }
        if let Some(v) = self.range_possible_clip {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(9, v);
        }
        if let Some(v) = self.timestamp_title.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.marker_icon.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.marker_description.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.marker_priority {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(14, v);
        }
        if let Some(v) = self.screenshot_handle {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.achievement_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(16, &v);
        }
        for value in &self.tag {
            let len = value.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.phase_id.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(18, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.timeline_id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.entry_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.time {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(4, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.game_mode {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.range_title.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.range_duration {
            os.write_uint64(8, v)?;
        }
        if let Some(v) = self.range_possible_clip {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.timestamp_title.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.marker_icon.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.marker_description.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.marker_priority {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.screenshot_handle {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.achievement_name.as_ref() {
            os.write_string(16, v)?;
        }
        for v in &self.tag {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        };
        if let Some(v) = self.phase_id.as_ref() {
            os.write_string(18, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CTimelineEntry {
        CTimelineEntry::new()
    }

    fn clear(&mut self) {
        self.timeline_id = ::std::option::Option::None;
        self.entry_id = ::std::option::Option::None;
        self.time = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.game_mode = ::std::option::Option::None;
        self.range_title = ::std::option::Option::None;
        self.range_duration = ::std::option::Option::None;
        self.range_possible_clip = ::std::option::Option::None;
        self.timestamp_title = ::std::option::Option::None;
        self.marker_icon = ::std::option::Option::None;
        self.marker_description = ::std::option::Option::None;
        self.marker_priority = ::std::option::Option::None;
        self.screenshot_handle = ::std::option::Option::None;
        self.achievement_name = ::std::option::Option::None;
        self.tag.clear();
        self.phase_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CTimelineEntry {
        static instance: CTimelineEntry = CTimelineEntry {
            timeline_id: ::std::option::Option::None,
            entry_id: ::std::option::Option::None,
            time: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            game_mode: ::std::option::Option::None,
            range_title: ::std::option::Option::None,
            range_duration: ::std::option::Option::None,
            range_possible_clip: ::std::option::Option::None,
            timestamp_title: ::std::option::Option::None,
            marker_icon: ::std::option::Option::None,
            marker_description: ::std::option::Option::None,
            marker_priority: ::std::option::Option::None,
            screenshot_handle: ::std::option::Option::None,
            achievement_name: ::std::option::Option::None,
            tag: ::std::vec::Vec::new(),
            phase_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_TimelineEntryChanged_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_TimelineEntryChanged_Notification {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_TimelineEntryChanged_Notification.entry)
    pub entry: ::steam_vent_proto_common::protobuf::MessageField<CTimelineEntry>,
    // @@protoc_insertion_point(field:CGameRecording_TimelineEntryChanged_Notification.game_id)
    pub game_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_TimelineEntryChanged_Notification.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_TimelineEntryChanged_Notification {
    fn default() -> &'a CGameRecording_TimelineEntryChanged_Notification {
        <CGameRecording_TimelineEntryChanged_Notification as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_TimelineEntryChanged_Notification {
    pub fn new() -> CGameRecording_TimelineEntryChanged_Notification {
        ::std::default::Default::default()
    }

    // optional fixed64 game_id = 2;

    pub fn game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_TimelineEntryChanged_Notification {
    const NAME: &'static str = "CGameRecording_TimelineEntryChanged_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.entry)?;
                },
                17 => {
                    self.game_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entry.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.game_id {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.entry.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.game_id {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_TimelineEntryChanged_Notification {
        CGameRecording_TimelineEntryChanged_Notification::new()
    }

    fn clear(&mut self) {
        self.entry.clear();
        self.game_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_TimelineEntryChanged_Notification {
        static instance: CGameRecording_TimelineEntryChanged_Notification = CGameRecording_TimelineEntryChanged_Notification {
            entry: ::steam_vent_proto_common::protobuf::MessageField::none(),
            game_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_LowDiskSpace_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_LowDiskSpace_Notification {
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_LowDiskSpace_Notification.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_LowDiskSpace_Notification {
    fn default() -> &'a CGameRecording_LowDiskSpace_Notification {
        <CGameRecording_LowDiskSpace_Notification as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_LowDiskSpace_Notification {
    pub fn new() -> CGameRecording_LowDiskSpace_Notification {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_LowDiskSpace_Notification {
    const NAME: &'static str = "CGameRecording_LowDiskSpace_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_LowDiskSpace_Notification {
        CGameRecording_LowDiskSpace_Notification::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_LowDiskSpace_Notification {
        static instance: CGameRecording_LowDiskSpace_Notification = CGameRecording_LowDiskSpace_Notification {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_PostGameHighlightsChanged_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_PostGameHighlightsChanged_Notification {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_PostGameHighlightsChanged_Notification.game_id)
    pub game_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_PostGameHighlightsChanged_Notification.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_PostGameHighlightsChanged_Notification {
    fn default() -> &'a CGameRecording_PostGameHighlightsChanged_Notification {
        <CGameRecording_PostGameHighlightsChanged_Notification as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_PostGameHighlightsChanged_Notification {
    pub fn new() -> CGameRecording_PostGameHighlightsChanged_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 game_id = 1;

    pub fn game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_PostGameHighlightsChanged_Notification {
    const NAME: &'static str = "CGameRecording_PostGameHighlightsChanged_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.game_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.game_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.game_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_PostGameHighlightsChanged_Notification {
        CGameRecording_PostGameHighlightsChanged_Notification::new()
    }

    fn clear(&mut self) {
        self.game_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_PostGameHighlightsChanged_Notification {
        static instance: CGameRecording_PostGameHighlightsChanged_Notification = CGameRecording_PostGameHighlightsChanged_Notification {
            game_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_ClipSummary)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_ClipSummary {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_ClipSummary.clip_id)
    pub clip_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameRecording_ClipSummary.game_id)
    pub game_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CGameRecording_ClipSummary.duration_ms)
    pub duration_ms: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CGameRecording_ClipSummary.date_recorded)
    pub date_recorded: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGameRecording_ClipSummary.start_timeline_id)
    pub start_timeline_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameRecording_ClipSummary.start_offset_ms)
    pub start_offset_ms: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CGameRecording_ClipSummary.published_file_id)
    pub published_file_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CGameRecording_ClipSummary.file_size)
    pub file_size: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CGameRecording_ClipSummary.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameRecording_ClipSummary.date_clipped)
    pub date_clipped: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGameRecording_ClipSummary.temporary)
    pub temporary: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CGameRecording_ClipSummary.original_device)
    pub original_device: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameRecording_ClipSummary.original_gaming_device_type)
    pub original_gaming_device_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGameRecording_ClipSummary.date_downloaded)
    pub date_downloaded: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGameRecording_ClipSummary.thumbnail_url)
    pub thumbnail_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameRecording_ClipSummary.thumbnail_width)
    pub thumbnail_width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGameRecording_ClipSummary.thumbnail_height)
    pub thumbnail_height: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_ClipSummary.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_ClipSummary {
    fn default() -> &'a CGameRecording_ClipSummary {
        <CGameRecording_ClipSummary as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_ClipSummary {
    pub fn new() -> CGameRecording_ClipSummary {
        ::std::default::Default::default()
    }

    // optional string clip_id = 1;

    pub fn clip_id(&self) -> &str {
        match self.clip_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_clip_id(&mut self) {
        self.clip_id = ::std::option::Option::None;
    }

    pub fn has_clip_id(&self) -> bool {
        self.clip_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clip_id(&mut self, v: ::std::string::String) {
        self.clip_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clip_id(&mut self) -> &mut ::std::string::String {
        if self.clip_id.is_none() {
            self.clip_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.clip_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_clip_id(&mut self) -> ::std::string::String {
        self.clip_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 game_id = 2;

    pub fn game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    // optional uint64 duration_ms = 3;

    pub fn duration_ms(&self) -> u64 {
        self.duration_ms.unwrap_or(0)
    }

    pub fn clear_duration_ms(&mut self) {
        self.duration_ms = ::std::option::Option::None;
    }

    pub fn has_duration_ms(&self) -> bool {
        self.duration_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration_ms(&mut self, v: u64) {
        self.duration_ms = ::std::option::Option::Some(v);
    }

    // optional uint32 date_recorded = 4;

    pub fn date_recorded(&self) -> u32 {
        self.date_recorded.unwrap_or(0)
    }

    pub fn clear_date_recorded(&mut self) {
        self.date_recorded = ::std::option::Option::None;
    }

    pub fn has_date_recorded(&self) -> bool {
        self.date_recorded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_date_recorded(&mut self, v: u32) {
        self.date_recorded = ::std::option::Option::Some(v);
    }

    // optional string start_timeline_id = 5;

    pub fn start_timeline_id(&self) -> &str {
        match self.start_timeline_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_start_timeline_id(&mut self) {
        self.start_timeline_id = ::std::option::Option::None;
    }

    pub fn has_start_timeline_id(&self) -> bool {
        self.start_timeline_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_timeline_id(&mut self, v: ::std::string::String) {
        self.start_timeline_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_timeline_id(&mut self) -> &mut ::std::string::String {
        if self.start_timeline_id.is_none() {
            self.start_timeline_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.start_timeline_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_start_timeline_id(&mut self) -> ::std::string::String {
        self.start_timeline_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 start_offset_ms = 6;

    pub fn start_offset_ms(&self) -> u64 {
        self.start_offset_ms.unwrap_or(0)
    }

    pub fn clear_start_offset_ms(&mut self) {
        self.start_offset_ms = ::std::option::Option::None;
    }

    pub fn has_start_offset_ms(&self) -> bool {
        self.start_offset_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_offset_ms(&mut self, v: u64) {
        self.start_offset_ms = ::std::option::Option::Some(v);
    }

    // optional uint64 published_file_id = 7;

    pub fn published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(0)
    }

    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }

    // optional uint64 file_size = 8;

    pub fn file_size(&self) -> u64 {
        self.file_size.unwrap_or(0)
    }

    pub fn clear_file_size(&mut self) {
        self.file_size = ::std::option::Option::None;
    }

    pub fn has_file_size(&self) -> bool {
        self.file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_size(&mut self, v: u64) {
        self.file_size = ::std::option::Option::Some(v);
    }

    // optional string name = 9;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 date_clipped = 10;

    pub fn date_clipped(&self) -> u32 {
        self.date_clipped.unwrap_or(0)
    }

    pub fn clear_date_clipped(&mut self) {
        self.date_clipped = ::std::option::Option::None;
    }

    pub fn has_date_clipped(&self) -> bool {
        self.date_clipped.is_some()
    }

    // Param is passed by value, moved
    pub fn set_date_clipped(&mut self, v: u32) {
        self.date_clipped = ::std::option::Option::Some(v);
    }

    // optional bool temporary = 11;

    pub fn temporary(&self) -> bool {
        self.temporary.unwrap_or(false)
    }

    pub fn clear_temporary(&mut self) {
        self.temporary = ::std::option::Option::None;
    }

    pub fn has_temporary(&self) -> bool {
        self.temporary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_temporary(&mut self, v: bool) {
        self.temporary = ::std::option::Option::Some(v);
    }

    // optional string original_device = 12;

    pub fn original_device(&self) -> &str {
        match self.original_device.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_original_device(&mut self) {
        self.original_device = ::std::option::Option::None;
    }

    pub fn has_original_device(&self) -> bool {
        self.original_device.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_device(&mut self, v: ::std::string::String) {
        self.original_device = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_original_device(&mut self) -> &mut ::std::string::String {
        if self.original_device.is_none() {
            self.original_device = ::std::option::Option::Some(::std::string::String::new());
        }
        self.original_device.as_mut().unwrap()
    }

    // Take field
    pub fn take_original_device(&mut self) -> ::std::string::String {
        self.original_device.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 original_gaming_device_type = 13;

    pub fn original_gaming_device_type(&self) -> u32 {
        self.original_gaming_device_type.unwrap_or(0)
    }

    pub fn clear_original_gaming_device_type(&mut self) {
        self.original_gaming_device_type = ::std::option::Option::None;
    }

    pub fn has_original_gaming_device_type(&self) -> bool {
        self.original_gaming_device_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_gaming_device_type(&mut self, v: u32) {
        self.original_gaming_device_type = ::std::option::Option::Some(v);
    }

    // optional uint32 date_downloaded = 14;

    pub fn date_downloaded(&self) -> u32 {
        self.date_downloaded.unwrap_or(0)
    }

    pub fn clear_date_downloaded(&mut self) {
        self.date_downloaded = ::std::option::Option::None;
    }

    pub fn has_date_downloaded(&self) -> bool {
        self.date_downloaded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_date_downloaded(&mut self, v: u32) {
        self.date_downloaded = ::std::option::Option::Some(v);
    }

    // optional string thumbnail_url = 15;

    pub fn thumbnail_url(&self) -> &str {
        match self.thumbnail_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_thumbnail_url(&mut self) {
        self.thumbnail_url = ::std::option::Option::None;
    }

    pub fn has_thumbnail_url(&self) -> bool {
        self.thumbnail_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnail_url(&mut self, v: ::std::string::String) {
        self.thumbnail_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnail_url(&mut self) -> &mut ::std::string::String {
        if self.thumbnail_url.is_none() {
            self.thumbnail_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.thumbnail_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnail_url(&mut self) -> ::std::string::String {
        self.thumbnail_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 thumbnail_width = 16;

    pub fn thumbnail_width(&self) -> u32 {
        self.thumbnail_width.unwrap_or(0)
    }

    pub fn clear_thumbnail_width(&mut self) {
        self.thumbnail_width = ::std::option::Option::None;
    }

    pub fn has_thumbnail_width(&self) -> bool {
        self.thumbnail_width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnail_width(&mut self, v: u32) {
        self.thumbnail_width = ::std::option::Option::Some(v);
    }

    // optional uint32 thumbnail_height = 17;

    pub fn thumbnail_height(&self) -> u32 {
        self.thumbnail_height.unwrap_or(0)
    }

    pub fn clear_thumbnail_height(&mut self) {
        self.thumbnail_height = ::std::option::Option::None;
    }

    pub fn has_thumbnail_height(&self) -> bool {
        self.thumbnail_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnail_height(&mut self, v: u32) {
        self.thumbnail_height = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_ClipSummary {
    const NAME: &'static str = "CGameRecording_ClipSummary";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.clip_id = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.game_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.duration_ms = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.date_recorded = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.start_timeline_id = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.start_offset_ms = ::std::option::Option::Some(is.read_uint64()?);
                },
                56 => {
                    self.published_file_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                64 => {
                    self.file_size = ::std::option::Option::Some(is.read_uint64()?);
                },
                74 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                80 => {
                    self.date_clipped = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.temporary = ::std::option::Option::Some(is.read_bool()?);
                },
                98 => {
                    self.original_device = ::std::option::Option::Some(is.read_string()?);
                },
                104 => {
                    self.original_gaming_device_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.date_downloaded = ::std::option::Option::Some(is.read_uint32()?);
                },
                122 => {
                    self.thumbnail_url = ::std::option::Option::Some(is.read_string()?);
                },
                128 => {
                    self.thumbnail_width = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.thumbnail_height = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.clip_id.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.game_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.duration_ms {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.date_recorded {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.start_timeline_id.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.start_offset_ms {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(6, v);
        }
        if let Some(v) = self.published_file_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(7, v);
        }
        if let Some(v) = self.file_size {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(8, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.date_clipped {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.temporary {
            my_size += 1 + 1;
        }
        if let Some(v) = self.original_device.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(12, &v);
        }
        if let Some(v) = self.original_gaming_device_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.date_downloaded {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.thumbnail_url.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.thumbnail_width {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.thumbnail_height {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(17, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.clip_id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.game_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.duration_ms {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.date_recorded {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.start_timeline_id.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.start_offset_ms {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.published_file_id {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.file_size {
            os.write_uint64(8, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.date_clipped {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.temporary {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.original_device.as_ref() {
            os.write_string(12, v)?;
        }
        if let Some(v) = self.original_gaming_device_type {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.date_downloaded {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.thumbnail_url.as_ref() {
            os.write_string(15, v)?;
        }
        if let Some(v) = self.thumbnail_width {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.thumbnail_height {
            os.write_uint32(17, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_ClipSummary {
        CGameRecording_ClipSummary::new()
    }

    fn clear(&mut self) {
        self.clip_id = ::std::option::Option::None;
        self.game_id = ::std::option::Option::None;
        self.duration_ms = ::std::option::Option::None;
        self.date_recorded = ::std::option::Option::None;
        self.start_timeline_id = ::std::option::Option::None;
        self.start_offset_ms = ::std::option::Option::None;
        self.published_file_id = ::std::option::Option::None;
        self.file_size = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.date_clipped = ::std::option::Option::None;
        self.temporary = ::std::option::Option::None;
        self.original_device = ::std::option::Option::None;
        self.original_gaming_device_type = ::std::option::Option::None;
        self.date_downloaded = ::std::option::Option::None;
        self.thumbnail_url = ::std::option::Option::None;
        self.thumbnail_width = ::std::option::Option::None;
        self.thumbnail_height = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_ClipSummary {
        static instance: CGameRecording_ClipSummary = CGameRecording_ClipSummary {
            clip_id: ::std::option::Option::None,
            game_id: ::std::option::Option::None,
            duration_ms: ::std::option::Option::None,
            date_recorded: ::std::option::Option::None,
            start_timeline_id: ::std::option::Option::None,
            start_offset_ms: ::std::option::Option::None,
            published_file_id: ::std::option::Option::None,
            file_size: ::std::option::Option::None,
            name: ::std::option::Option::None,
            date_clipped: ::std::option::Option::None,
            temporary: ::std::option::Option::None,
            original_device: ::std::option::Option::None,
            original_gaming_device_type: ::std::option::Option::None,
            date_downloaded: ::std::option::Option::None,
            thumbnail_url: ::std::option::Option::None,
            thumbnail_width: ::std::option::Option::None,
            thumbnail_height: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_SaveClip_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_SaveClip_Request {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_SaveClip_Request.game_id)
    pub game_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CGameRecording_SaveClip_Request.start)
    pub start: ::steam_vent_proto_common::protobuf::MessageField<cgame_recording_save_clip_request::Position>,
    // @@protoc_insertion_point(field:CGameRecording_SaveClip_Request.end)
    pub end: ::steam_vent_proto_common::protobuf::MessageField<cgame_recording_save_clip_request::Position>,
    // @@protoc_insertion_point(field:CGameRecording_SaveClip_Request.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameRecording_SaveClip_Request.src_clip_id)
    pub src_clip_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameRecording_SaveClip_Request.temporary)
    pub temporary: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_SaveClip_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_SaveClip_Request {
    fn default() -> &'a CGameRecording_SaveClip_Request {
        <CGameRecording_SaveClip_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_SaveClip_Request {
    pub fn new() -> CGameRecording_SaveClip_Request {
        ::std::default::Default::default()
    }

    // optional uint64 game_id = 1;

    pub fn game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    // optional string name = 4;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string src_clip_id = 5;

    pub fn src_clip_id(&self) -> &str {
        match self.src_clip_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_src_clip_id(&mut self) {
        self.src_clip_id = ::std::option::Option::None;
    }

    pub fn has_src_clip_id(&self) -> bool {
        self.src_clip_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src_clip_id(&mut self, v: ::std::string::String) {
        self.src_clip_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src_clip_id(&mut self) -> &mut ::std::string::String {
        if self.src_clip_id.is_none() {
            self.src_clip_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.src_clip_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_src_clip_id(&mut self) -> ::std::string::String {
        self.src_clip_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool temporary = 6;

    pub fn temporary(&self) -> bool {
        self.temporary.unwrap_or(false)
    }

    pub fn clear_temporary(&mut self) {
        self.temporary = ::std::option::Option::None;
    }

    pub fn has_temporary(&self) -> bool {
        self.temporary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_temporary(&mut self, v: bool) {
        self.temporary = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_SaveClip_Request {
    const NAME: &'static str = "CGameRecording_SaveClip_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.game_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.start)?;
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.end)?;
                },
                34 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.src_clip_id = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.temporary = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.game_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.start.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.end.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.src_clip_id.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.temporary {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.game_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.start.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.end.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.src_clip_id.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.temporary {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_SaveClip_Request {
        CGameRecording_SaveClip_Request::new()
    }

    fn clear(&mut self) {
        self.game_id = ::std::option::Option::None;
        self.start.clear();
        self.end.clear();
        self.name = ::std::option::Option::None;
        self.src_clip_id = ::std::option::Option::None;
        self.temporary = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_SaveClip_Request {
        static instance: CGameRecording_SaveClip_Request = CGameRecording_SaveClip_Request {
            game_id: ::std::option::Option::None,
            start: ::steam_vent_proto_common::protobuf::MessageField::none(),
            end: ::steam_vent_proto_common::protobuf::MessageField::none(),
            name: ::std::option::Option::None,
            src_clip_id: ::std::option::Option::None,
            temporary: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CGameRecording_SaveClip_Request`
pub mod cgame_recording_save_clip_request {
    // @@protoc_insertion_point(message:CGameRecording_SaveClip_Request.Position)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Position {
        // message fields
        // @@protoc_insertion_point(field:CGameRecording_SaveClip_Request.Position.timeline_id)
        pub timeline_id: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CGameRecording_SaveClip_Request.Position.offset_ms)
        pub offset_ms: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CGameRecording_SaveClip_Request.Position.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Position {
        fn default() -> &'a Position {
            <Position as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Position {
        pub fn new() -> Position {
            ::std::default::Default::default()
        }

        // optional string timeline_id = 1;

        pub fn timeline_id(&self) -> &str {
            match self.timeline_id.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_timeline_id(&mut self) {
            self.timeline_id = ::std::option::Option::None;
        }

        pub fn has_timeline_id(&self) -> bool {
            self.timeline_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timeline_id(&mut self, v: ::std::string::String) {
            self.timeline_id = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_timeline_id(&mut self) -> &mut ::std::string::String {
            if self.timeline_id.is_none() {
                self.timeline_id = ::std::option::Option::Some(::std::string::String::new());
            }
            self.timeline_id.as_mut().unwrap()
        }

        // Take field
        pub fn take_timeline_id(&mut self) -> ::std::string::String {
            self.timeline_id.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint64 offset_ms = 2;

        pub fn offset_ms(&self) -> u64 {
            self.offset_ms.unwrap_or(0)
        }

        pub fn clear_offset_ms(&mut self) {
            self.offset_ms = ::std::option::Option::None;
        }

        pub fn has_offset_ms(&self) -> bool {
            self.offset_ms.is_some()
        }

        // Param is passed by value, moved
        pub fn set_offset_ms(&mut self, v: u64) {
            self.offset_ms = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Position {
        const NAME: &'static str = "Position";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.timeline_id = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.offset_ms = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.timeline_id.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.offset_ms {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.timeline_id.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.offset_ms {
                os.write_uint64(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Position {
            Position::new()
        }

        fn clear(&mut self) {
            self.timeline_id = ::std::option::Option::None;
            self.offset_ms = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Position {
            static instance: Position = Position {
                timeline_id: ::std::option::Option::None,
                offset_ms: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CGameRecording_SaveClip_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_SaveClip_Response {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_SaveClip_Response.summary)
    pub summary: ::steam_vent_proto_common::protobuf::MessageField<CGameRecording_ClipSummary>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_SaveClip_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_SaveClip_Response {
    fn default() -> &'a CGameRecording_SaveClip_Response {
        <CGameRecording_SaveClip_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_SaveClip_Response {
    pub fn new() -> CGameRecording_SaveClip_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_SaveClip_Response {
    const NAME: &'static str = "CGameRecording_SaveClip_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.summary)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.summary.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_SaveClip_Response {
        CGameRecording_SaveClip_Response::new()
    }

    fn clear(&mut self) {
        self.summary.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_SaveClip_Response {
        static instance: CGameRecording_SaveClip_Response = CGameRecording_SaveClip_Response {
            summary: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_DeleteClip_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_DeleteClip_Request {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_DeleteClip_Request.clip_id)
    pub clip_id: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_DeleteClip_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_DeleteClip_Request {
    fn default() -> &'a CGameRecording_DeleteClip_Request {
        <CGameRecording_DeleteClip_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_DeleteClip_Request {
    pub fn new() -> CGameRecording_DeleteClip_Request {
        ::std::default::Default::default()
    }

    // optional string clip_id = 1;

    pub fn clip_id(&self) -> &str {
        match self.clip_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_clip_id(&mut self) {
        self.clip_id = ::std::option::Option::None;
    }

    pub fn has_clip_id(&self) -> bool {
        self.clip_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clip_id(&mut self, v: ::std::string::String) {
        self.clip_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clip_id(&mut self) -> &mut ::std::string::String {
        if self.clip_id.is_none() {
            self.clip_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.clip_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_clip_id(&mut self) -> ::std::string::String {
        self.clip_id.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_DeleteClip_Request {
    const NAME: &'static str = "CGameRecording_DeleteClip_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.clip_id = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.clip_id.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.clip_id.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_DeleteClip_Request {
        CGameRecording_DeleteClip_Request::new()
    }

    fn clear(&mut self) {
        self.clip_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_DeleteClip_Request {
        static instance: CGameRecording_DeleteClip_Request = CGameRecording_DeleteClip_Request {
            clip_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_DeleteClip_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_DeleteClip_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_DeleteClip_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_DeleteClip_Response {
    fn default() -> &'a CGameRecording_DeleteClip_Response {
        <CGameRecording_DeleteClip_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_DeleteClip_Response {
    pub fn new() -> CGameRecording_DeleteClip_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_DeleteClip_Response {
    const NAME: &'static str = "CGameRecording_DeleteClip_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_DeleteClip_Response {
        CGameRecording_DeleteClip_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_DeleteClip_Response {
        static instance: CGameRecording_DeleteClip_Response = CGameRecording_DeleteClip_Response {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_ExportClip_Settings)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_ExportClip_Settings {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_ExportClip_Settings.bitrate_kbps)
    pub bitrate_kbps: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CGameRecording_ExportClip_Settings.width)
    pub width: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CGameRecording_ExportClip_Settings.height)
    pub height: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CGameRecording_ExportClip_Settings.frames_per_second)
    pub frames_per_second: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_ExportClip_Settings.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_ExportClip_Settings {
    fn default() -> &'a CGameRecording_ExportClip_Settings {
        <CGameRecording_ExportClip_Settings as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_ExportClip_Settings {
    pub fn new() -> CGameRecording_ExportClip_Settings {
        ::std::default::Default::default()
    }

    // optional int32 bitrate_kbps = 1;

    pub fn bitrate_kbps(&self) -> i32 {
        self.bitrate_kbps.unwrap_or(0)
    }

    pub fn clear_bitrate_kbps(&mut self) {
        self.bitrate_kbps = ::std::option::Option::None;
    }

    pub fn has_bitrate_kbps(&self) -> bool {
        self.bitrate_kbps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bitrate_kbps(&mut self, v: i32) {
        self.bitrate_kbps = ::std::option::Option::Some(v);
    }

    // optional int32 width = 2;

    pub fn width(&self) -> i32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: i32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional int32 height = 3;

    pub fn height(&self) -> i32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional int32 frames_per_second = 4;

    pub fn frames_per_second(&self) -> i32 {
        self.frames_per_second.unwrap_or(0)
    }

    pub fn clear_frames_per_second(&mut self) {
        self.frames_per_second = ::std::option::Option::None;
    }

    pub fn has_frames_per_second(&self) -> bool {
        self.frames_per_second.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frames_per_second(&mut self, v: i32) {
        self.frames_per_second = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_ExportClip_Settings {
    const NAME: &'static str = "CGameRecording_ExportClip_Settings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.bitrate_kbps = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.width = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.height = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.frames_per_second = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.bitrate_kbps {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.width {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.height {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.frames_per_second {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.bitrate_kbps {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.width {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.height {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.frames_per_second {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_ExportClip_Settings {
        CGameRecording_ExportClip_Settings::new()
    }

    fn clear(&mut self) {
        self.bitrate_kbps = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.frames_per_second = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_ExportClip_Settings {
        static instance: CGameRecording_ExportClip_Settings = CGameRecording_ExportClip_Settings {
            bitrate_kbps: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            frames_per_second: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_ExportClip_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_ExportClip_Request {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_ExportClip_Request.clip_id)
    pub clip_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameRecording_ExportClip_Request.export_mp4_path)
    pub export_mp4_path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameRecording_ExportClip_Request.settings)
    pub settings: ::steam_vent_proto_common::protobuf::MessageField<CGameRecording_ExportClip_Settings>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_ExportClip_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_ExportClip_Request {
    fn default() -> &'a CGameRecording_ExportClip_Request {
        <CGameRecording_ExportClip_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_ExportClip_Request {
    pub fn new() -> CGameRecording_ExportClip_Request {
        ::std::default::Default::default()
    }

    // optional string clip_id = 1;

    pub fn clip_id(&self) -> &str {
        match self.clip_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_clip_id(&mut self) {
        self.clip_id = ::std::option::Option::None;
    }

    pub fn has_clip_id(&self) -> bool {
        self.clip_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clip_id(&mut self, v: ::std::string::String) {
        self.clip_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clip_id(&mut self) -> &mut ::std::string::String {
        if self.clip_id.is_none() {
            self.clip_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.clip_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_clip_id(&mut self) -> ::std::string::String {
        self.clip_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string export_mp4_path = 2;

    pub fn export_mp4_path(&self) -> &str {
        match self.export_mp4_path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_export_mp4_path(&mut self) {
        self.export_mp4_path = ::std::option::Option::None;
    }

    pub fn has_export_mp4_path(&self) -> bool {
        self.export_mp4_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_export_mp4_path(&mut self, v: ::std::string::String) {
        self.export_mp4_path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_export_mp4_path(&mut self) -> &mut ::std::string::String {
        if self.export_mp4_path.is_none() {
            self.export_mp4_path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.export_mp4_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_export_mp4_path(&mut self) -> ::std::string::String {
        self.export_mp4_path.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_ExportClip_Request {
    const NAME: &'static str = "CGameRecording_ExportClip_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.clip_id = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.export_mp4_path = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.settings)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.clip_id.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.export_mp4_path.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.clip_id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.export_mp4_path.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.settings.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_ExportClip_Request {
        CGameRecording_ExportClip_Request::new()
    }

    fn clear(&mut self) {
        self.clip_id = ::std::option::Option::None;
        self.export_mp4_path = ::std::option::Option::None;
        self.settings.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_ExportClip_Request {
        static instance: CGameRecording_ExportClip_Request = CGameRecording_ExportClip_Request {
            clip_id: ::std::option::Option::None,
            export_mp4_path: ::std::option::Option::None,
            settings: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_ExportClip_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_ExportClip_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_ExportClip_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_ExportClip_Response {
    fn default() -> &'a CGameRecording_ExportClip_Response {
        <CGameRecording_ExportClip_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_ExportClip_Response {
    pub fn new() -> CGameRecording_ExportClip_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_ExportClip_Response {
    const NAME: &'static str = "CGameRecording_ExportClip_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_ExportClip_Response {
        CGameRecording_ExportClip_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_ExportClip_Response {
        static instance: CGameRecording_ExportClip_Response = CGameRecording_ExportClip_Response {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_TakeScreenshot_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_TakeScreenshot_Request {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_TakeScreenshot_Request.game_id)
    pub game_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CGameRecording_TakeScreenshot_Request.timeline_id)
    pub timeline_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameRecording_TakeScreenshot_Request.timeline_offset_ms)
    pub timeline_offset_ms: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_TakeScreenshot_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_TakeScreenshot_Request {
    fn default() -> &'a CGameRecording_TakeScreenshot_Request {
        <CGameRecording_TakeScreenshot_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_TakeScreenshot_Request {
    pub fn new() -> CGameRecording_TakeScreenshot_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 game_id = 1;

    pub fn game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    // optional string timeline_id = 2;

    pub fn timeline_id(&self) -> &str {
        match self.timeline_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_timeline_id(&mut self) {
        self.timeline_id = ::std::option::Option::None;
    }

    pub fn has_timeline_id(&self) -> bool {
        self.timeline_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeline_id(&mut self, v: ::std::string::String) {
        self.timeline_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_timeline_id(&mut self) -> &mut ::std::string::String {
        if self.timeline_id.is_none() {
            self.timeline_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.timeline_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_timeline_id(&mut self) -> ::std::string::String {
        self.timeline_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 timeline_offset_ms = 3;

    pub fn timeline_offset_ms(&self) -> u64 {
        self.timeline_offset_ms.unwrap_or(0)
    }

    pub fn clear_timeline_offset_ms(&mut self) {
        self.timeline_offset_ms = ::std::option::Option::None;
    }

    pub fn has_timeline_offset_ms(&self) -> bool {
        self.timeline_offset_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeline_offset_ms(&mut self, v: u64) {
        self.timeline_offset_ms = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_TakeScreenshot_Request {
    const NAME: &'static str = "CGameRecording_TakeScreenshot_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.game_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    self.timeline_id = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.timeline_offset_ms = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.game_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.timeline_id.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.timeline_offset_ms {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.game_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.timeline_id.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.timeline_offset_ms {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_TakeScreenshot_Request {
        CGameRecording_TakeScreenshot_Request::new()
    }

    fn clear(&mut self) {
        self.game_id = ::std::option::Option::None;
        self.timeline_id = ::std::option::Option::None;
        self.timeline_offset_ms = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_TakeScreenshot_Request {
        static instance: CGameRecording_TakeScreenshot_Request = CGameRecording_TakeScreenshot_Request {
            game_id: ::std::option::Option::None,
            timeline_id: ::std::option::Option::None,
            timeline_offset_ms: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_TakeScreenshot_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_TakeScreenshot_Response {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_TakeScreenshot_Response.screenshot_id)
    pub screenshot_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_TakeScreenshot_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_TakeScreenshot_Response {
    fn default() -> &'a CGameRecording_TakeScreenshot_Response {
        <CGameRecording_TakeScreenshot_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_TakeScreenshot_Response {
    pub fn new() -> CGameRecording_TakeScreenshot_Response {
        ::std::default::Default::default()
    }

    // optional fixed64 screenshot_id = 1;

    pub fn screenshot_id(&self) -> u64 {
        self.screenshot_id.unwrap_or(0)
    }

    pub fn clear_screenshot_id(&mut self) {
        self.screenshot_id = ::std::option::Option::None;
    }

    pub fn has_screenshot_id(&self) -> bool {
        self.screenshot_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_screenshot_id(&mut self, v: u64) {
        self.screenshot_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_TakeScreenshot_Response {
    const NAME: &'static str = "CGameRecording_TakeScreenshot_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.screenshot_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.screenshot_id {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.screenshot_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_TakeScreenshot_Response {
        CGameRecording_TakeScreenshot_Response::new()
    }

    fn clear(&mut self) {
        self.screenshot_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_TakeScreenshot_Response {
        static instance: CGameRecording_TakeScreenshot_Response = CGameRecording_TakeScreenshot_Response {
            screenshot_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_UploadClipToSteam_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_UploadClipToSteam_Request {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_UploadClipToSteam_Request.clip_id)
    pub clip_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameRecording_UploadClipToSteam_Request.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameRecording_UploadClipToSteam_Request.desc)
    pub desc: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameRecording_UploadClipToSteam_Request.visibility)
    pub visibility: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_UploadClipToSteam_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_UploadClipToSteam_Request {
    fn default() -> &'a CGameRecording_UploadClipToSteam_Request {
        <CGameRecording_UploadClipToSteam_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_UploadClipToSteam_Request {
    pub fn new() -> CGameRecording_UploadClipToSteam_Request {
        ::std::default::Default::default()
    }

    // optional string clip_id = 1;

    pub fn clip_id(&self) -> &str {
        match self.clip_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_clip_id(&mut self) {
        self.clip_id = ::std::option::Option::None;
    }

    pub fn has_clip_id(&self) -> bool {
        self.clip_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clip_id(&mut self, v: ::std::string::String) {
        self.clip_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clip_id(&mut self) -> &mut ::std::string::String {
        if self.clip_id.is_none() {
            self.clip_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.clip_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_clip_id(&mut self) -> ::std::string::String {
        self.clip_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string title = 2;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string desc = 3;

    pub fn desc(&self) -> &str {
        match self.desc.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_desc(&mut self) {
        self.desc = ::std::option::Option::None;
    }

    pub fn has_desc(&self) -> bool {
        self.desc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desc(&mut self, v: ::std::string::String) {
        self.desc = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desc(&mut self) -> &mut ::std::string::String {
        if self.desc.is_none() {
            self.desc = ::std::option::Option::Some(::std::string::String::new());
        }
        self.desc.as_mut().unwrap()
    }

    // Take field
    pub fn take_desc(&mut self) -> ::std::string::String {
        self.desc.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 visibility = 4;

    pub fn visibility(&self) -> i32 {
        self.visibility.unwrap_or(0)
    }

    pub fn clear_visibility(&mut self) {
        self.visibility = ::std::option::Option::None;
    }

    pub fn has_visibility(&self) -> bool {
        self.visibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visibility(&mut self, v: i32) {
        self.visibility = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_UploadClipToSteam_Request {
    const NAME: &'static str = "CGameRecording_UploadClipToSteam_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.clip_id = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.desc = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.visibility = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.clip_id.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.desc.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.visibility {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.clip_id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.desc.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.visibility {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_UploadClipToSteam_Request {
        CGameRecording_UploadClipToSteam_Request::new()
    }

    fn clear(&mut self) {
        self.clip_id = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.desc = ::std::option::Option::None;
        self.visibility = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_UploadClipToSteam_Request {
        static instance: CGameRecording_UploadClipToSteam_Request = CGameRecording_UploadClipToSteam_Request {
            clip_id: ::std::option::Option::None,
            title: ::std::option::Option::None,
            desc: ::std::option::Option::None,
            visibility: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_UploadClipToSteam_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_UploadClipToSteam_Response {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_UploadClipToSteam_Response.summary)
    pub summary: ::steam_vent_proto_common::protobuf::MessageField<CGameRecording_ClipSummary>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_UploadClipToSteam_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_UploadClipToSteam_Response {
    fn default() -> &'a CGameRecording_UploadClipToSteam_Response {
        <CGameRecording_UploadClipToSteam_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_UploadClipToSteam_Response {
    pub fn new() -> CGameRecording_UploadClipToSteam_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_UploadClipToSteam_Response {
    const NAME: &'static str = "CGameRecording_UploadClipToSteam_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.summary)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.summary.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_UploadClipToSteam_Response {
        CGameRecording_UploadClipToSteam_Response::new()
    }

    fn clear(&mut self) {
        self.summary.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_UploadClipToSteam_Response {
        static instance: CGameRecording_UploadClipToSteam_Response = CGameRecording_UploadClipToSteam_Response {
            summary: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_ZipClip_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_ZipClip_Request {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_ZipClip_Request.clip_id)
    pub clip_id: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_ZipClip_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_ZipClip_Request {
    fn default() -> &'a CGameRecording_ZipClip_Request {
        <CGameRecording_ZipClip_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_ZipClip_Request {
    pub fn new() -> CGameRecording_ZipClip_Request {
        ::std::default::Default::default()
    }

    // optional string clip_id = 1;

    pub fn clip_id(&self) -> &str {
        match self.clip_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_clip_id(&mut self) {
        self.clip_id = ::std::option::Option::None;
    }

    pub fn has_clip_id(&self) -> bool {
        self.clip_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clip_id(&mut self, v: ::std::string::String) {
        self.clip_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clip_id(&mut self) -> &mut ::std::string::String {
        if self.clip_id.is_none() {
            self.clip_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.clip_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_clip_id(&mut self) -> ::std::string::String {
        self.clip_id.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_ZipClip_Request {
    const NAME: &'static str = "CGameRecording_ZipClip_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.clip_id = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.clip_id.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.clip_id.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_ZipClip_Request {
        CGameRecording_ZipClip_Request::new()
    }

    fn clear(&mut self) {
        self.clip_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_ZipClip_Request {
        static instance: CGameRecording_ZipClip_Request = CGameRecording_ZipClip_Request {
            clip_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_ZipClip_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_ZipClip_Response {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_ZipClip_Response.zip_path)
    pub zip_path: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_ZipClip_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_ZipClip_Response {
    fn default() -> &'a CGameRecording_ZipClip_Response {
        <CGameRecording_ZipClip_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_ZipClip_Response {
    pub fn new() -> CGameRecording_ZipClip_Response {
        ::std::default::Default::default()
    }

    // optional string zip_path = 1;

    pub fn zip_path(&self) -> &str {
        match self.zip_path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_zip_path(&mut self) {
        self.zip_path = ::std::option::Option::None;
    }

    pub fn has_zip_path(&self) -> bool {
        self.zip_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_zip_path(&mut self, v: ::std::string::String) {
        self.zip_path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_zip_path(&mut self) -> &mut ::std::string::String {
        if self.zip_path.is_none() {
            self.zip_path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.zip_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_zip_path(&mut self) -> ::std::string::String {
        self.zip_path.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_ZipClip_Response {
    const NAME: &'static str = "CGameRecording_ZipClip_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.zip_path = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.zip_path.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.zip_path.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_ZipClip_Response {
        CGameRecording_ZipClip_Response::new()
    }

    fn clear(&mut self) {
        self.zip_path = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_ZipClip_Response {
        static instance: CGameRecording_ZipClip_Response = CGameRecording_ZipClip_Response {
            zip_path: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_GetClips_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_GetClips_Request {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_GetClips_Request.game_id)
    pub game_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CGameRecording_GetClips_Request.created_after)
    pub created_after: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGameRecording_GetClips_Request.include_temporary)
    pub include_temporary: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_GetClips_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_GetClips_Request {
    fn default() -> &'a CGameRecording_GetClips_Request {
        <CGameRecording_GetClips_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_GetClips_Request {
    pub fn new() -> CGameRecording_GetClips_Request {
        ::std::default::Default::default()
    }

    // optional uint64 game_id = 1;

    pub fn game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    // optional uint32 created_after = 2;

    pub fn created_after(&self) -> u32 {
        self.created_after.unwrap_or(0)
    }

    pub fn clear_created_after(&mut self) {
        self.created_after = ::std::option::Option::None;
    }

    pub fn has_created_after(&self) -> bool {
        self.created_after.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created_after(&mut self, v: u32) {
        self.created_after = ::std::option::Option::Some(v);
    }

    // optional bool include_temporary = 3;

    pub fn include_temporary(&self) -> bool {
        self.include_temporary.unwrap_or(false)
    }

    pub fn clear_include_temporary(&mut self) {
        self.include_temporary = ::std::option::Option::None;
    }

    pub fn has_include_temporary(&self) -> bool {
        self.include_temporary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_temporary(&mut self, v: bool) {
        self.include_temporary = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_GetClips_Request {
    const NAME: &'static str = "CGameRecording_GetClips_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.game_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.created_after = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.include_temporary = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.game_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.created_after {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.include_temporary {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.game_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.created_after {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.include_temporary {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_GetClips_Request {
        CGameRecording_GetClips_Request::new()
    }

    fn clear(&mut self) {
        self.game_id = ::std::option::Option::None;
        self.created_after = ::std::option::Option::None;
        self.include_temporary = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_GetClips_Request {
        static instance: CGameRecording_GetClips_Request = CGameRecording_GetClips_Request {
            game_id: ::std::option::Option::None,
            created_after: ::std::option::Option::None,
            include_temporary: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_GetClips_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_GetClips_Response {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_GetClips_Response.clip)
    pub clip: ::std::vec::Vec<CGameRecording_ClipSummary>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_GetClips_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_GetClips_Response {
    fn default() -> &'a CGameRecording_GetClips_Response {
        <CGameRecording_GetClips_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_GetClips_Response {
    pub fn new() -> CGameRecording_GetClips_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_GetClips_Response {
    const NAME: &'static str = "CGameRecording_GetClips_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.clip.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.clip {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.clip {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_GetClips_Response {
        CGameRecording_GetClips_Response::new()
    }

    fn clear(&mut self) {
        self.clip.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_GetClips_Response {
        static instance: CGameRecording_GetClips_Response = CGameRecording_GetClips_Response {
            clip: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_GetAndTrimPostGameHighlights_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_GetAndTrimPostGameHighlights_Request {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_GetAndTrimPostGameHighlights_Request.game_id)
    pub game_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CGameRecording_GetAndTrimPostGameHighlights_Request.created_after)
    pub created_after: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_GetAndTrimPostGameHighlights_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_GetAndTrimPostGameHighlights_Request {
    fn default() -> &'a CGameRecording_GetAndTrimPostGameHighlights_Request {
        <CGameRecording_GetAndTrimPostGameHighlights_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_GetAndTrimPostGameHighlights_Request {
    pub fn new() -> CGameRecording_GetAndTrimPostGameHighlights_Request {
        ::std::default::Default::default()
    }

    // optional uint64 game_id = 1;

    pub fn game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    // optional uint32 created_after = 2;

    pub fn created_after(&self) -> u32 {
        self.created_after.unwrap_or(0)
    }

    pub fn clear_created_after(&mut self) {
        self.created_after = ::std::option::Option::None;
    }

    pub fn has_created_after(&self) -> bool {
        self.created_after.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created_after(&mut self, v: u32) {
        self.created_after = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_GetAndTrimPostGameHighlights_Request {
    const NAME: &'static str = "CGameRecording_GetAndTrimPostGameHighlights_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.game_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.created_after = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.game_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.created_after {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.game_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.created_after {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_GetAndTrimPostGameHighlights_Request {
        CGameRecording_GetAndTrimPostGameHighlights_Request::new()
    }

    fn clear(&mut self) {
        self.game_id = ::std::option::Option::None;
        self.created_after = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_GetAndTrimPostGameHighlights_Request {
        static instance: CGameRecording_GetAndTrimPostGameHighlights_Request = CGameRecording_GetAndTrimPostGameHighlights_Request {
            game_id: ::std::option::Option::None,
            created_after: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_GetAndTrimPostGameHighlights_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_GetAndTrimPostGameHighlights_Response {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_GetAndTrimPostGameHighlights_Response.events)
    pub events: ::std::vec::Vec<super::webuimessages_gamerecordingfiles::CGameRecordingTimelineEvent>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_GetAndTrimPostGameHighlights_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_GetAndTrimPostGameHighlights_Response {
    fn default() -> &'a CGameRecording_GetAndTrimPostGameHighlights_Response {
        <CGameRecording_GetAndTrimPostGameHighlights_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_GetAndTrimPostGameHighlights_Response {
    pub fn new() -> CGameRecording_GetAndTrimPostGameHighlights_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_GetAndTrimPostGameHighlights_Response {
    const NAME: &'static str = "CGameRecording_GetAndTrimPostGameHighlights_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.events.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.events {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_GetAndTrimPostGameHighlights_Response {
        CGameRecording_GetAndTrimPostGameHighlights_Response::new()
    }

    fn clear(&mut self) {
        self.events.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_GetAndTrimPostGameHighlights_Response {
        static instance: CGameRecording_GetAndTrimPostGameHighlights_Response = CGameRecording_GetAndTrimPostGameHighlights_Response {
            events: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_UserAddTimelineEntry_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_UserAddTimelineEntry_Request {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_UserAddTimelineEntry_Request.game_id)
    pub game_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CGameRecording_UserAddTimelineEntry_Request.entry)
    pub entry: ::steam_vent_proto_common::protobuf::MessageField<CTimelineEntry>,
    // @@protoc_insertion_point(field:CGameRecording_UserAddTimelineEntry_Request.clip_id)
    pub clip_id: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_UserAddTimelineEntry_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_UserAddTimelineEntry_Request {
    fn default() -> &'a CGameRecording_UserAddTimelineEntry_Request {
        <CGameRecording_UserAddTimelineEntry_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_UserAddTimelineEntry_Request {
    pub fn new() -> CGameRecording_UserAddTimelineEntry_Request {
        ::std::default::Default::default()
    }

    // optional uint64 game_id = 1;

    pub fn game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    // optional string clip_id = 3;

    pub fn clip_id(&self) -> &str {
        match self.clip_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_clip_id(&mut self) {
        self.clip_id = ::std::option::Option::None;
    }

    pub fn has_clip_id(&self) -> bool {
        self.clip_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clip_id(&mut self, v: ::std::string::String) {
        self.clip_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clip_id(&mut self) -> &mut ::std::string::String {
        if self.clip_id.is_none() {
            self.clip_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.clip_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_clip_id(&mut self) -> ::std::string::String {
        self.clip_id.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_UserAddTimelineEntry_Request {
    const NAME: &'static str = "CGameRecording_UserAddTimelineEntry_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.game_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.entry)?;
                },
                26 => {
                    self.clip_id = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.game_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.entry.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.clip_id.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.game_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.entry.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.clip_id.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_UserAddTimelineEntry_Request {
        CGameRecording_UserAddTimelineEntry_Request::new()
    }

    fn clear(&mut self) {
        self.game_id = ::std::option::Option::None;
        self.entry.clear();
        self.clip_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_UserAddTimelineEntry_Request {
        static instance: CGameRecording_UserAddTimelineEntry_Request = CGameRecording_UserAddTimelineEntry_Request {
            game_id: ::std::option::Option::None,
            entry: ::steam_vent_proto_common::protobuf::MessageField::none(),
            clip_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_UserAddTimelineEntry_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_UserAddTimelineEntry_Response {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_UserAddTimelineEntry_Response.entry_id)
    pub entry_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_UserAddTimelineEntry_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_UserAddTimelineEntry_Response {
    fn default() -> &'a CGameRecording_UserAddTimelineEntry_Response {
        <CGameRecording_UserAddTimelineEntry_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_UserAddTimelineEntry_Response {
    pub fn new() -> CGameRecording_UserAddTimelineEntry_Response {
        ::std::default::Default::default()
    }

    // optional uint64 entry_id = 1;

    pub fn entry_id(&self) -> u64 {
        self.entry_id.unwrap_or(0)
    }

    pub fn clear_entry_id(&mut self) {
        self.entry_id = ::std::option::Option::None;
    }

    pub fn has_entry_id(&self) -> bool {
        self.entry_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entry_id(&mut self, v: u64) {
        self.entry_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_UserAddTimelineEntry_Response {
    const NAME: &'static str = "CGameRecording_UserAddTimelineEntry_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.entry_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entry_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.entry_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_UserAddTimelineEntry_Response {
        CGameRecording_UserAddTimelineEntry_Response::new()
    }

    fn clear(&mut self) {
        self.entry_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_UserAddTimelineEntry_Response {
        static instance: CGameRecording_UserAddTimelineEntry_Response = CGameRecording_UserAddTimelineEntry_Response {
            entry_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_UserUpdateTimelineEntry_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_UserUpdateTimelineEntry_Request {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_UserUpdateTimelineEntry_Request.game_id)
    pub game_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CGameRecording_UserUpdateTimelineEntry_Request.entry)
    pub entry: ::steam_vent_proto_common::protobuf::MessageField<CTimelineEntry>,
    // @@protoc_insertion_point(field:CGameRecording_UserUpdateTimelineEntry_Request.clip_id)
    pub clip_id: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_UserUpdateTimelineEntry_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_UserUpdateTimelineEntry_Request {
    fn default() -> &'a CGameRecording_UserUpdateTimelineEntry_Request {
        <CGameRecording_UserUpdateTimelineEntry_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_UserUpdateTimelineEntry_Request {
    pub fn new() -> CGameRecording_UserUpdateTimelineEntry_Request {
        ::std::default::Default::default()
    }

    // optional uint64 game_id = 1;

    pub fn game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    // optional string clip_id = 3;

    pub fn clip_id(&self) -> &str {
        match self.clip_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_clip_id(&mut self) {
        self.clip_id = ::std::option::Option::None;
    }

    pub fn has_clip_id(&self) -> bool {
        self.clip_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clip_id(&mut self, v: ::std::string::String) {
        self.clip_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clip_id(&mut self) -> &mut ::std::string::String {
        if self.clip_id.is_none() {
            self.clip_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.clip_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_clip_id(&mut self) -> ::std::string::String {
        self.clip_id.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_UserUpdateTimelineEntry_Request {
    const NAME: &'static str = "CGameRecording_UserUpdateTimelineEntry_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.game_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.entry)?;
                },
                26 => {
                    self.clip_id = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.game_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.entry.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.clip_id.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.game_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.entry.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.clip_id.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_UserUpdateTimelineEntry_Request {
        CGameRecording_UserUpdateTimelineEntry_Request::new()
    }

    fn clear(&mut self) {
        self.game_id = ::std::option::Option::None;
        self.entry.clear();
        self.clip_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_UserUpdateTimelineEntry_Request {
        static instance: CGameRecording_UserUpdateTimelineEntry_Request = CGameRecording_UserUpdateTimelineEntry_Request {
            game_id: ::std::option::Option::None,
            entry: ::steam_vent_proto_common::protobuf::MessageField::none(),
            clip_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_UserUpdateTimelineEntry_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_UserUpdateTimelineEntry_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_UserUpdateTimelineEntry_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_UserUpdateTimelineEntry_Response {
    fn default() -> &'a CGameRecording_UserUpdateTimelineEntry_Response {
        <CGameRecording_UserUpdateTimelineEntry_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_UserUpdateTimelineEntry_Response {
    pub fn new() -> CGameRecording_UserUpdateTimelineEntry_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_UserUpdateTimelineEntry_Response {
    const NAME: &'static str = "CGameRecording_UserUpdateTimelineEntry_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_UserUpdateTimelineEntry_Response {
        CGameRecording_UserUpdateTimelineEntry_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_UserUpdateTimelineEntry_Response {
        static instance: CGameRecording_UserUpdateTimelineEntry_Response = CGameRecording_UserUpdateTimelineEntry_Response {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_UserRemoveTimelineEntry_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_UserRemoveTimelineEntry_Request {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_UserRemoveTimelineEntry_Request.game_id)
    pub game_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CGameRecording_UserRemoveTimelineEntry_Request.timeline_id)
    pub timeline_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameRecording_UserRemoveTimelineEntry_Request.entry_id)
    pub entry_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CGameRecording_UserRemoveTimelineEntry_Request.clip_id)
    pub clip_id: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_UserRemoveTimelineEntry_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_UserRemoveTimelineEntry_Request {
    fn default() -> &'a CGameRecording_UserRemoveTimelineEntry_Request {
        <CGameRecording_UserRemoveTimelineEntry_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_UserRemoveTimelineEntry_Request {
    pub fn new() -> CGameRecording_UserRemoveTimelineEntry_Request {
        ::std::default::Default::default()
    }

    // optional uint64 game_id = 1;

    pub fn game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    // optional string timeline_id = 2;

    pub fn timeline_id(&self) -> &str {
        match self.timeline_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_timeline_id(&mut self) {
        self.timeline_id = ::std::option::Option::None;
    }

    pub fn has_timeline_id(&self) -> bool {
        self.timeline_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeline_id(&mut self, v: ::std::string::String) {
        self.timeline_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_timeline_id(&mut self) -> &mut ::std::string::String {
        if self.timeline_id.is_none() {
            self.timeline_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.timeline_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_timeline_id(&mut self) -> ::std::string::String {
        self.timeline_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 entry_id = 3;

    pub fn entry_id(&self) -> u64 {
        self.entry_id.unwrap_or(0)
    }

    pub fn clear_entry_id(&mut self) {
        self.entry_id = ::std::option::Option::None;
    }

    pub fn has_entry_id(&self) -> bool {
        self.entry_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entry_id(&mut self, v: u64) {
        self.entry_id = ::std::option::Option::Some(v);
    }

    // optional string clip_id = 4;

    pub fn clip_id(&self) -> &str {
        match self.clip_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_clip_id(&mut self) {
        self.clip_id = ::std::option::Option::None;
    }

    pub fn has_clip_id(&self) -> bool {
        self.clip_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clip_id(&mut self, v: ::std::string::String) {
        self.clip_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clip_id(&mut self) -> &mut ::std::string::String {
        if self.clip_id.is_none() {
            self.clip_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.clip_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_clip_id(&mut self) -> ::std::string::String {
        self.clip_id.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_UserRemoveTimelineEntry_Request {
    const NAME: &'static str = "CGameRecording_UserRemoveTimelineEntry_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.game_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.timeline_id = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.entry_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                34 => {
                    self.clip_id = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.game_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.timeline_id.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.entry_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.clip_id.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.game_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.timeline_id.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.entry_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.clip_id.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_UserRemoveTimelineEntry_Request {
        CGameRecording_UserRemoveTimelineEntry_Request::new()
    }

    fn clear(&mut self) {
        self.game_id = ::std::option::Option::None;
        self.timeline_id = ::std::option::Option::None;
        self.entry_id = ::std::option::Option::None;
        self.clip_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_UserRemoveTimelineEntry_Request {
        static instance: CGameRecording_UserRemoveTimelineEntry_Request = CGameRecording_UserRemoveTimelineEntry_Request {
            game_id: ::std::option::Option::None,
            timeline_id: ::std::option::Option::None,
            entry_id: ::std::option::Option::None,
            clip_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_UserRemoveTimelineEntry_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_UserRemoveTimelineEntry_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_UserRemoveTimelineEntry_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_UserRemoveTimelineEntry_Response {
    fn default() -> &'a CGameRecording_UserRemoveTimelineEntry_Response {
        <CGameRecording_UserRemoveTimelineEntry_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_UserRemoveTimelineEntry_Response {
    pub fn new() -> CGameRecording_UserRemoveTimelineEntry_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_UserRemoveTimelineEntry_Response {
    const NAME: &'static str = "CGameRecording_UserRemoveTimelineEntry_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_UserRemoveTimelineEntry_Response {
        CGameRecording_UserRemoveTimelineEntry_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_UserRemoveTimelineEntry_Response {
        static instance: CGameRecording_UserRemoveTimelineEntry_Response = CGameRecording_UserRemoveTimelineEntry_Response {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_ManuallyDeleteRecordingsForApps_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_ManuallyDeleteRecordingsForApps_Request {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_ManuallyDeleteRecordingsForApps_Request.game_ids)
    pub game_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_ManuallyDeleteRecordingsForApps_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_ManuallyDeleteRecordingsForApps_Request {
    fn default() -> &'a CGameRecording_ManuallyDeleteRecordingsForApps_Request {
        <CGameRecording_ManuallyDeleteRecordingsForApps_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_ManuallyDeleteRecordingsForApps_Request {
    pub fn new() -> CGameRecording_ManuallyDeleteRecordingsForApps_Request {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_ManuallyDeleteRecordingsForApps_Request {
    const NAME: &'static str = "CGameRecording_ManuallyDeleteRecordingsForApps_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.game_ids)?;
                },
                8 => {
                    self.game_ids.push(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.game_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.game_ids {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_ManuallyDeleteRecordingsForApps_Request {
        CGameRecording_ManuallyDeleteRecordingsForApps_Request::new()
    }

    fn clear(&mut self) {
        self.game_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_ManuallyDeleteRecordingsForApps_Request {
        static instance: CGameRecording_ManuallyDeleteRecordingsForApps_Request = CGameRecording_ManuallyDeleteRecordingsForApps_Request {
            game_ids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_ManuallyDeleteRecordingsForApps_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_ManuallyDeleteRecordingsForApps_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_ManuallyDeleteRecordingsForApps_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_ManuallyDeleteRecordingsForApps_Response {
    fn default() -> &'a CGameRecording_ManuallyDeleteRecordingsForApps_Response {
        <CGameRecording_ManuallyDeleteRecordingsForApps_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_ManuallyDeleteRecordingsForApps_Response {
    pub fn new() -> CGameRecording_ManuallyDeleteRecordingsForApps_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_ManuallyDeleteRecordingsForApps_Response {
    const NAME: &'static str = "CGameRecording_ManuallyDeleteRecordingsForApps_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_ManuallyDeleteRecordingsForApps_Response {
        CGameRecording_ManuallyDeleteRecordingsForApps_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_ManuallyDeleteRecordingsForApps_Response {
        static instance: CGameRecording_ManuallyDeleteRecordingsForApps_Response = CGameRecording_ManuallyDeleteRecordingsForApps_Response {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_GetTotalDiskSpaceUsage_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_GetTotalDiskSpaceUsage_Request {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_GetTotalDiskSpaceUsage_Request.folder_path)
    pub folder_path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameRecording_GetTotalDiskSpaceUsage_Request.type)
    pub type_: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EDiskSpaceType>>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_GetTotalDiskSpaceUsage_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_GetTotalDiskSpaceUsage_Request {
    fn default() -> &'a CGameRecording_GetTotalDiskSpaceUsage_Request {
        <CGameRecording_GetTotalDiskSpaceUsage_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_GetTotalDiskSpaceUsage_Request {
    pub fn new() -> CGameRecording_GetTotalDiskSpaceUsage_Request {
        ::std::default::Default::default()
    }

    // optional string folder_path = 1;

    pub fn folder_path(&self) -> &str {
        match self.folder_path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_folder_path(&mut self) {
        self.folder_path = ::std::option::Option::None;
    }

    pub fn has_folder_path(&self) -> bool {
        self.folder_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_folder_path(&mut self, v: ::std::string::String) {
        self.folder_path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_folder_path(&mut self) -> &mut ::std::string::String {
        if self.folder_path.is_none() {
            self.folder_path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.folder_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_folder_path(&mut self) -> ::std::string::String {
        self.folder_path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .EDiskSpaceType type = 2;

    pub fn type_(&self) -> EDiskSpaceType {
        match self.type_ {
            Some(e) => e.enum_value_or(EDiskSpaceType::k_eDiskSpaceType_Recording),
            None => EDiskSpaceType::k_eDiskSpaceType_Recording,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: EDiskSpaceType) {
        self.type_ = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_GetTotalDiskSpaceUsage_Request {
    const NAME: &'static str = "CGameRecording_GetTotalDiskSpaceUsage_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.folder_path = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.folder_path.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.type_ {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.folder_path.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_GetTotalDiskSpaceUsage_Request {
        CGameRecording_GetTotalDiskSpaceUsage_Request::new()
    }

    fn clear(&mut self) {
        self.folder_path = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_GetTotalDiskSpaceUsage_Request {
        static instance: CGameRecording_GetTotalDiskSpaceUsage_Request = CGameRecording_GetTotalDiskSpaceUsage_Request {
            folder_path: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_GetTotalDiskSpaceUsage_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_GetTotalDiskSpaceUsage_Response {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_GetTotalDiskSpaceUsage_Response.size)
    pub size: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_GetTotalDiskSpaceUsage_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_GetTotalDiskSpaceUsage_Response {
    fn default() -> &'a CGameRecording_GetTotalDiskSpaceUsage_Response {
        <CGameRecording_GetTotalDiskSpaceUsage_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_GetTotalDiskSpaceUsage_Response {
    pub fn new() -> CGameRecording_GetTotalDiskSpaceUsage_Response {
        ::std::default::Default::default()
    }

    // optional uint64 size = 1;

    pub fn size(&self) -> u64 {
        self.size.unwrap_or(0)
    }

    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u64) {
        self.size = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_GetTotalDiskSpaceUsage_Response {
    const NAME: &'static str = "CGameRecording_GetTotalDiskSpaceUsage_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.size = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.size {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.size {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_GetTotalDiskSpaceUsage_Response {
        CGameRecording_GetTotalDiskSpaceUsage_Response::new()
    }

    fn clear(&mut self) {
        self.size = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_GetTotalDiskSpaceUsage_Response {
        static instance: CGameRecording_GetTotalDiskSpaceUsage_Response = CGameRecording_GetTotalDiskSpaceUsage_Response {
            size: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_GetThumbnails_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_GetThumbnails_Request {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_GetThumbnails_Request.recording_id)
    pub recording_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameRecording_GetThumbnails_Request.clip_id)
    pub clip_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameRecording_GetThumbnails_Request.timeline_id)
    pub timeline_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameRecording_GetThumbnails_Request.start_offset_us)
    pub start_offset_us: ::std::vec::Vec<i64>,
    // @@protoc_insertion_point(field:CGameRecording_GetThumbnails_Request.major_axis)
    pub major_axis: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGameRecording_GetThumbnails_Request.time_precision)
    pub time_precision: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EThumbnailTimePrecision>>,
    // @@protoc_insertion_point(field:CGameRecording_GetThumbnails_Request.format)
    pub format: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EThumbnailFormat>>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_GetThumbnails_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_GetThumbnails_Request {
    fn default() -> &'a CGameRecording_GetThumbnails_Request {
        <CGameRecording_GetThumbnails_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_GetThumbnails_Request {
    pub fn new() -> CGameRecording_GetThumbnails_Request {
        ::std::default::Default::default()
    }

    // optional string recording_id = 1;

    pub fn recording_id(&self) -> &str {
        match self.recording_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_recording_id(&mut self) {
        self.recording_id = ::std::option::Option::None;
    }

    pub fn has_recording_id(&self) -> bool {
        self.recording_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recording_id(&mut self, v: ::std::string::String) {
        self.recording_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_recording_id(&mut self) -> &mut ::std::string::String {
        if self.recording_id.is_none() {
            self.recording_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.recording_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_recording_id(&mut self) -> ::std::string::String {
        self.recording_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string clip_id = 3;

    pub fn clip_id(&self) -> &str {
        match self.clip_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_clip_id(&mut self) {
        self.clip_id = ::std::option::Option::None;
    }

    pub fn has_clip_id(&self) -> bool {
        self.clip_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clip_id(&mut self, v: ::std::string::String) {
        self.clip_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clip_id(&mut self) -> &mut ::std::string::String {
        if self.clip_id.is_none() {
            self.clip_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.clip_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_clip_id(&mut self) -> ::std::string::String {
        self.clip_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string timeline_id = 7;

    pub fn timeline_id(&self) -> &str {
        match self.timeline_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_timeline_id(&mut self) {
        self.timeline_id = ::std::option::Option::None;
    }

    pub fn has_timeline_id(&self) -> bool {
        self.timeline_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeline_id(&mut self, v: ::std::string::String) {
        self.timeline_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_timeline_id(&mut self) -> &mut ::std::string::String {
        if self.timeline_id.is_none() {
            self.timeline_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.timeline_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_timeline_id(&mut self) -> ::std::string::String {
        self.timeline_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 major_axis = 5;

    pub fn major_axis(&self) -> u32 {
        self.major_axis.unwrap_or(512u32)
    }

    pub fn clear_major_axis(&mut self) {
        self.major_axis = ::std::option::Option::None;
    }

    pub fn has_major_axis(&self) -> bool {
        self.major_axis.is_some()
    }

    // Param is passed by value, moved
    pub fn set_major_axis(&mut self, v: u32) {
        self.major_axis = ::std::option::Option::Some(v);
    }

    // optional .EThumbnailTimePrecision time_precision = 6;

    pub fn time_precision(&self) -> EThumbnailTimePrecision {
        match self.time_precision {
            Some(e) => e.enum_value_or(EThumbnailTimePrecision::k_ePrecise),
            None => EThumbnailTimePrecision::k_ePrecise,
        }
    }

    pub fn clear_time_precision(&mut self) {
        self.time_precision = ::std::option::Option::None;
    }

    pub fn has_time_precision(&self) -> bool {
        self.time_precision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_precision(&mut self, v: EThumbnailTimePrecision) {
        self.time_precision = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional .EThumbnailFormat format = 8;

    pub fn format(&self) -> EThumbnailFormat {
        match self.format {
            Some(e) => e.enum_value_or(EThumbnailFormat::k_eJPEG),
            None => EThumbnailFormat::k_eJPEG,
        }
    }

    pub fn clear_format(&mut self) {
        self.format = ::std::option::Option::None;
    }

    pub fn has_format(&self) -> bool {
        self.format.is_some()
    }

    // Param is passed by value, moved
    pub fn set_format(&mut self, v: EThumbnailFormat) {
        self.format = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_GetThumbnails_Request {
    const NAME: &'static str = "CGameRecording_GetThumbnails_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.recording_id = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.clip_id = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.timeline_id = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    is.read_repeated_packed_int64_into(&mut self.start_offset_us)?;
                },
                32 => {
                    self.start_offset_us.push(is.read_int64()?);
                },
                40 => {
                    self.major_axis = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.time_precision = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                64 => {
                    self.format = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.recording_id.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.clip_id.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.timeline_id.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(7, &v);
        }
        for value in &self.start_offset_us {
            my_size += ::steam_vent_proto_common::protobuf::rt::int64_size(4, *value);
        };
        if let Some(v) = self.major_axis {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.time_precision {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.format {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(8, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.recording_id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.clip_id.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.timeline_id.as_ref() {
            os.write_string(7, v)?;
        }
        for v in &self.start_offset_us {
            os.write_int64(4, *v)?;
        };
        if let Some(v) = self.major_axis {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.time_precision {
            os.write_enum(6, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.format {
            os.write_enum(8, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_GetThumbnails_Request {
        CGameRecording_GetThumbnails_Request::new()
    }

    fn clear(&mut self) {
        self.recording_id = ::std::option::Option::None;
        self.clip_id = ::std::option::Option::None;
        self.timeline_id = ::std::option::Option::None;
        self.start_offset_us.clear();
        self.major_axis = ::std::option::Option::None;
        self.time_precision = ::std::option::Option::None;
        self.format = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_GetThumbnails_Request {
        static instance: CGameRecording_GetThumbnails_Request = CGameRecording_GetThumbnails_Request {
            recording_id: ::std::option::Option::None,
            clip_id: ::std::option::Option::None,
            timeline_id: ::std::option::Option::None,
            start_offset_us: ::std::vec::Vec::new(),
            major_axis: ::std::option::Option::None,
            time_precision: ::std::option::Option::None,
            format: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_GetThumbnails_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_GetThumbnails_Response {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_GetThumbnails_Response.thumbnails)
    pub thumbnails: ::std::vec::Vec<cgame_recording_get_thumbnails_response::Thumbnail>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_GetThumbnails_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_GetThumbnails_Response {
    fn default() -> &'a CGameRecording_GetThumbnails_Response {
        <CGameRecording_GetThumbnails_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_GetThumbnails_Response {
    pub fn new() -> CGameRecording_GetThumbnails_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_GetThumbnails_Response {
    const NAME: &'static str = "CGameRecording_GetThumbnails_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.thumbnails.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.thumbnails {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.thumbnails {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_GetThumbnails_Response {
        CGameRecording_GetThumbnails_Response::new()
    }

    fn clear(&mut self) {
        self.thumbnails.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_GetThumbnails_Response {
        static instance: CGameRecording_GetThumbnails_Response = CGameRecording_GetThumbnails_Response {
            thumbnails: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CGameRecording_GetThumbnails_Response`
pub mod cgame_recording_get_thumbnails_response {
    // @@protoc_insertion_point(message:CGameRecording_GetThumbnails_Response.Thumbnail)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Thumbnail {
        // message fields
        // @@protoc_insertion_point(field:CGameRecording_GetThumbnails_Response.Thumbnail.image_data)
        pub image_data: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:CGameRecording_GetThumbnails_Response.Thumbnail.width)
        pub width: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CGameRecording_GetThumbnails_Response.Thumbnail.height)
        pub height: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CGameRecording_GetThumbnails_Response.Thumbnail.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Thumbnail {
        fn default() -> &'a Thumbnail {
            <Thumbnail as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Thumbnail {
        pub fn new() -> Thumbnail {
            ::std::default::Default::default()
        }

        // optional bytes image_data = 1;

        pub fn image_data(&self) -> &[u8] {
            match self.image_data.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_image_data(&mut self) {
            self.image_data = ::std::option::Option::None;
        }

        pub fn has_image_data(&self) -> bool {
            self.image_data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_image_data(&mut self, v: ::std::vec::Vec<u8>) {
            self.image_data = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_image_data(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.image_data.is_none() {
                self.image_data = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.image_data.as_mut().unwrap()
        }

        // Take field
        pub fn take_image_data(&mut self) -> ::std::vec::Vec<u8> {
            self.image_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional uint32 width = 2;

        pub fn width(&self) -> u32 {
            self.width.unwrap_or(0)
        }

        pub fn clear_width(&mut self) {
            self.width = ::std::option::Option::None;
        }

        pub fn has_width(&self) -> bool {
            self.width.is_some()
        }

        // Param is passed by value, moved
        pub fn set_width(&mut self, v: u32) {
            self.width = ::std::option::Option::Some(v);
        }

        // optional uint32 height = 3;

        pub fn height(&self) -> u32 {
            self.height.unwrap_or(0)
        }

        pub fn clear_height(&mut self) {
            self.height = ::std::option::Option::None;
        }

        pub fn has_height(&self) -> bool {
            self.height.is_some()
        }

        // Param is passed by value, moved
        pub fn set_height(&mut self, v: u32) {
            self.height = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Thumbnail {
        const NAME: &'static str = "Thumbnail";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.image_data = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    16 => {
                        self.width = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.height = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.image_data.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(1, &v);
            }
            if let Some(v) = self.width {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.height {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.image_data.as_ref() {
                os.write_bytes(1, v)?;
            }
            if let Some(v) = self.width {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.height {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Thumbnail {
            Thumbnail::new()
        }

        fn clear(&mut self) {
            self.image_data = ::std::option::Option::None;
            self.width = ::std::option::Option::None;
            self.height = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Thumbnail {
            static instance: Thumbnail = Thumbnail {
                image_data: ::std::option::Option::None,
                width: ::std::option::Option::None,
                height: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CGameRecording_StartRecording_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_StartRecording_Request {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_StartRecording_Request.game_id)
    pub game_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_StartRecording_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_StartRecording_Request {
    fn default() -> &'a CGameRecording_StartRecording_Request {
        <CGameRecording_StartRecording_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_StartRecording_Request {
    pub fn new() -> CGameRecording_StartRecording_Request {
        ::std::default::Default::default()
    }

    // optional uint64 game_id = 1;

    pub fn game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_StartRecording_Request {
    const NAME: &'static str = "CGameRecording_StartRecording_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.game_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.game_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.game_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_StartRecording_Request {
        CGameRecording_StartRecording_Request::new()
    }

    fn clear(&mut self) {
        self.game_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_StartRecording_Request {
        static instance: CGameRecording_StartRecording_Request = CGameRecording_StartRecording_Request {
            game_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_StartRecording_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_StartRecording_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_StartRecording_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_StartRecording_Response {
    fn default() -> &'a CGameRecording_StartRecording_Response {
        <CGameRecording_StartRecording_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_StartRecording_Response {
    pub fn new() -> CGameRecording_StartRecording_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_StartRecording_Response {
    const NAME: &'static str = "CGameRecording_StartRecording_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_StartRecording_Response {
        CGameRecording_StartRecording_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_StartRecording_Response {
        static instance: CGameRecording_StartRecording_Response = CGameRecording_StartRecording_Response {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_StopRecording_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_StopRecording_Request {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_StopRecording_Request.game_id)
    pub game_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_StopRecording_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_StopRecording_Request {
    fn default() -> &'a CGameRecording_StopRecording_Request {
        <CGameRecording_StopRecording_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_StopRecording_Request {
    pub fn new() -> CGameRecording_StopRecording_Request {
        ::std::default::Default::default()
    }

    // optional uint64 game_id = 1;

    pub fn game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_StopRecording_Request {
    const NAME: &'static str = "CGameRecording_StopRecording_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.game_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.game_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.game_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_StopRecording_Request {
        CGameRecording_StopRecording_Request::new()
    }

    fn clear(&mut self) {
        self.game_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_StopRecording_Request {
        static instance: CGameRecording_StopRecording_Request = CGameRecording_StopRecording_Request {
            game_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_StopRecording_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_StopRecording_Response {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_StopRecording_Response.summary)
    pub summary: ::steam_vent_proto_common::protobuf::MessageField<CGameRecording_ClipSummary>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_StopRecording_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_StopRecording_Response {
    fn default() -> &'a CGameRecording_StopRecording_Response {
        <CGameRecording_StopRecording_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_StopRecording_Response {
    pub fn new() -> CGameRecording_StopRecording_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_StopRecording_Response {
    const NAME: &'static str = "CGameRecording_StopRecording_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.summary)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.summary.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_StopRecording_Response {
        CGameRecording_StopRecording_Response::new()
    }

    fn clear(&mut self) {
        self.summary.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_StopRecording_Response {
        static instance: CGameRecording_StopRecording_Response = CGameRecording_StopRecording_Response {
            summary: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_GetRecordingSize_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_GetRecordingSize_Request {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_GetRecordingSize_Request.game_id)
    pub game_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_GetRecordingSize_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_GetRecordingSize_Request {
    fn default() -> &'a CGameRecording_GetRecordingSize_Request {
        <CGameRecording_GetRecordingSize_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_GetRecordingSize_Request {
    pub fn new() -> CGameRecording_GetRecordingSize_Request {
        ::std::default::Default::default()
    }

    // optional uint64 game_id = 1;

    pub fn game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_GetRecordingSize_Request {
    const NAME: &'static str = "CGameRecording_GetRecordingSize_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.game_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.game_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.game_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_GetRecordingSize_Request {
        CGameRecording_GetRecordingSize_Request::new()
    }

    fn clear(&mut self) {
        self.game_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_GetRecordingSize_Request {
        static instance: CGameRecording_GetRecordingSize_Request = CGameRecording_GetRecordingSize_Request {
            game_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_GetRecordingSize_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_GetRecordingSize_Response {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_GetRecordingSize_Response.file_size)
    pub file_size: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_GetRecordingSize_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_GetRecordingSize_Response {
    fn default() -> &'a CGameRecording_GetRecordingSize_Response {
        <CGameRecording_GetRecordingSize_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_GetRecordingSize_Response {
    pub fn new() -> CGameRecording_GetRecordingSize_Response {
        ::std::default::Default::default()
    }

    // optional uint64 file_size = 1;

    pub fn file_size(&self) -> u64 {
        self.file_size.unwrap_or(0)
    }

    pub fn clear_file_size(&mut self) {
        self.file_size = ::std::option::Option::None;
    }

    pub fn has_file_size(&self) -> bool {
        self.file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_size(&mut self, v: u64) {
        self.file_size = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_GetRecordingSize_Response {
    const NAME: &'static str = "CGameRecording_GetRecordingSize_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.file_size = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.file_size {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.file_size {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_GetRecordingSize_Response {
        CGameRecording_GetRecordingSize_Response::new()
    }

    fn clear(&mut self) {
        self.file_size = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_GetRecordingSize_Response {
        static instance: CGameRecording_GetRecordingSize_Response = CGameRecording_GetRecordingSize_Response {
            file_size: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_CleanupBackgroundRecordings_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_CleanupBackgroundRecordings_Request {
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_CleanupBackgroundRecordings_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_CleanupBackgroundRecordings_Request {
    fn default() -> &'a CGameRecording_CleanupBackgroundRecordings_Request {
        <CGameRecording_CleanupBackgroundRecordings_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_CleanupBackgroundRecordings_Request {
    pub fn new() -> CGameRecording_CleanupBackgroundRecordings_Request {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_CleanupBackgroundRecordings_Request {
    const NAME: &'static str = "CGameRecording_CleanupBackgroundRecordings_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_CleanupBackgroundRecordings_Request {
        CGameRecording_CleanupBackgroundRecordings_Request::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_CleanupBackgroundRecordings_Request {
        static instance: CGameRecording_CleanupBackgroundRecordings_Request = CGameRecording_CleanupBackgroundRecordings_Request {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_CleanupBackgroundRecordings_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_CleanupBackgroundRecordings_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_CleanupBackgroundRecordings_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_CleanupBackgroundRecordings_Response {
    fn default() -> &'a CGameRecording_CleanupBackgroundRecordings_Response {
        <CGameRecording_CleanupBackgroundRecordings_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_CleanupBackgroundRecordings_Response {
    pub fn new() -> CGameRecording_CleanupBackgroundRecordings_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_CleanupBackgroundRecordings_Response {
    const NAME: &'static str = "CGameRecording_CleanupBackgroundRecordings_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_CleanupBackgroundRecordings_Response {
        CGameRecording_CleanupBackgroundRecordings_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_CleanupBackgroundRecordings_Response {
        static instance: CGameRecording_CleanupBackgroundRecordings_Response = CGameRecording_CleanupBackgroundRecordings_Response {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_GetPlatformCapabilities_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_GetPlatformCapabilities_Request {
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_GetPlatformCapabilities_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_GetPlatformCapabilities_Request {
    fn default() -> &'a CGameRecording_GetPlatformCapabilities_Request {
        <CGameRecording_GetPlatformCapabilities_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_GetPlatformCapabilities_Request {
    pub fn new() -> CGameRecording_GetPlatformCapabilities_Request {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_GetPlatformCapabilities_Request {
    const NAME: &'static str = "CGameRecording_GetPlatformCapabilities_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_GetPlatformCapabilities_Request {
        CGameRecording_GetPlatformCapabilities_Request::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_GetPlatformCapabilities_Request {
        static instance: CGameRecording_GetPlatformCapabilities_Request = CGameRecording_GetPlatformCapabilities_Request {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_GetPlatformCapabilities_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_GetPlatformCapabilities_Response {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_GetPlatformCapabilities_Response.per_process_audio_capture)
    pub per_process_audio_capture: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_GetPlatformCapabilities_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_GetPlatformCapabilities_Response {
    fn default() -> &'a CGameRecording_GetPlatformCapabilities_Response {
        <CGameRecording_GetPlatformCapabilities_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_GetPlatformCapabilities_Response {
    pub fn new() -> CGameRecording_GetPlatformCapabilities_Response {
        ::std::default::Default::default()
    }

    // optional bool per_process_audio_capture = 1;

    pub fn per_process_audio_capture(&self) -> bool {
        self.per_process_audio_capture.unwrap_or(false)
    }

    pub fn clear_per_process_audio_capture(&mut self) {
        self.per_process_audio_capture = ::std::option::Option::None;
    }

    pub fn has_per_process_audio_capture(&self) -> bool {
        self.per_process_audio_capture.is_some()
    }

    // Param is passed by value, moved
    pub fn set_per_process_audio_capture(&mut self, v: bool) {
        self.per_process_audio_capture = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_GetPlatformCapabilities_Response {
    const NAME: &'static str = "CGameRecording_GetPlatformCapabilities_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.per_process_audio_capture = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.per_process_audio_capture {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.per_process_audio_capture {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_GetPlatformCapabilities_Response {
        CGameRecording_GetPlatformCapabilities_Response::new()
    }

    fn clear(&mut self) {
        self.per_process_audio_capture = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_GetPlatformCapabilities_Response {
        static instance: CGameRecording_GetPlatformCapabilities_Response = CGameRecording_GetPlatformCapabilities_Response {
            per_process_audio_capture: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_ClipCreated_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_ClipCreated_Notification {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_ClipCreated_Notification.summary)
    pub summary: ::steam_vent_proto_common::protobuf::MessageField<CGameRecording_ClipSummary>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_ClipCreated_Notification.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_ClipCreated_Notification {
    fn default() -> &'a CGameRecording_ClipCreated_Notification {
        <CGameRecording_ClipCreated_Notification as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_ClipCreated_Notification {
    pub fn new() -> CGameRecording_ClipCreated_Notification {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_ClipCreated_Notification {
    const NAME: &'static str = "CGameRecording_ClipCreated_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.summary)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.summary.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_ClipCreated_Notification {
        CGameRecording_ClipCreated_Notification::new()
    }

    fn clear(&mut self) {
        self.summary.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_ClipCreated_Notification {
        static instance: CGameRecording_ClipCreated_Notification = CGameRecording_ClipCreated_Notification {
            summary: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_ClipDeleted_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_ClipDeleted_Notification {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_ClipDeleted_Notification.clip_id)
    pub clip_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameRecording_ClipDeleted_Notification.game_id)
    pub game_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_ClipDeleted_Notification.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_ClipDeleted_Notification {
    fn default() -> &'a CGameRecording_ClipDeleted_Notification {
        <CGameRecording_ClipDeleted_Notification as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_ClipDeleted_Notification {
    pub fn new() -> CGameRecording_ClipDeleted_Notification {
        ::std::default::Default::default()
    }

    // optional string clip_id = 1;

    pub fn clip_id(&self) -> &str {
        match self.clip_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_clip_id(&mut self) {
        self.clip_id = ::std::option::Option::None;
    }

    pub fn has_clip_id(&self) -> bool {
        self.clip_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clip_id(&mut self, v: ::std::string::String) {
        self.clip_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clip_id(&mut self) -> &mut ::std::string::String {
        if self.clip_id.is_none() {
            self.clip_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.clip_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_clip_id(&mut self) -> ::std::string::String {
        self.clip_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 game_id = 2;

    pub fn game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_ClipDeleted_Notification {
    const NAME: &'static str = "CGameRecording_ClipDeleted_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.clip_id = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.game_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.clip_id.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.game_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.clip_id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.game_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_ClipDeleted_Notification {
        CGameRecording_ClipDeleted_Notification::new()
    }

    fn clear(&mut self) {
        self.clip_id = ::std::option::Option::None;
        self.game_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_ClipDeleted_Notification {
        static instance: CGameRecording_ClipDeleted_Notification = CGameRecording_ClipDeleted_Notification {
            clip_id: ::std::option::Option::None,
            game_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_ExportProgress_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_ExportProgress_Notification {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_ExportProgress_Notification.progress)
    pub progress: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CGameRecording_ExportProgress_Notification.clip_id)
    pub clip_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameRecording_ExportProgress_Notification.eresult)
    pub eresult: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_ExportProgress_Notification.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_ExportProgress_Notification {
    fn default() -> &'a CGameRecording_ExportProgress_Notification {
        <CGameRecording_ExportProgress_Notification as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_ExportProgress_Notification {
    pub fn new() -> CGameRecording_ExportProgress_Notification {
        ::std::default::Default::default()
    }

    // optional float progress = 1;

    pub fn progress(&self) -> f32 {
        self.progress.unwrap_or(0.)
    }

    pub fn clear_progress(&mut self) {
        self.progress = ::std::option::Option::None;
    }

    pub fn has_progress(&self) -> bool {
        self.progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_progress(&mut self, v: f32) {
        self.progress = ::std::option::Option::Some(v);
    }

    // optional string clip_id = 2;

    pub fn clip_id(&self) -> &str {
        match self.clip_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_clip_id(&mut self) {
        self.clip_id = ::std::option::Option::None;
    }

    pub fn has_clip_id(&self) -> bool {
        self.clip_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clip_id(&mut self, v: ::std::string::String) {
        self.clip_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clip_id(&mut self) -> &mut ::std::string::String {
        if self.clip_id.is_none() {
            self.clip_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.clip_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_clip_id(&mut self) -> ::std::string::String {
        self.clip_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 eresult = 3;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(0)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_ExportProgress_Notification {
    const NAME: &'static str = "CGameRecording_ExportProgress_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.progress = ::std::option::Option::Some(is.read_float()?);
                },
                18 => {
                    self.clip_id = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.progress {
            my_size += 1 + 4;
        }
        if let Some(v) = self.clip_id.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.eresult {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.progress {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.clip_id.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_ExportProgress_Notification {
        CGameRecording_ExportProgress_Notification::new()
    }

    fn clear(&mut self) {
        self.progress = ::std::option::Option::None;
        self.clip_id = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_ExportProgress_Notification {
        static instance: CGameRecording_ExportProgress_Notification = CGameRecording_ExportProgress_Notification {
            progress: ::std::option::Option::None,
            clip_id: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_PerGameSettings)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_PerGameSettings {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_PerGameSettings.gameid)
    pub gameid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CGameRecording_PerGameSettings.enabled)
    pub enabled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_PerGameSettings.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_PerGameSettings {
    fn default() -> &'a CGameRecording_PerGameSettings {
        <CGameRecording_PerGameSettings as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_PerGameSettings {
    pub fn new() -> CGameRecording_PerGameSettings {
        ::std::default::Default::default()
    }

    // optional fixed64 gameid = 1;

    pub fn gameid(&self) -> u64 {
        self.gameid.unwrap_or(0)
    }

    pub fn clear_gameid(&mut self) {
        self.gameid = ::std::option::Option::None;
    }

    pub fn has_gameid(&self) -> bool {
        self.gameid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameid(&mut self, v: u64) {
        self.gameid = ::std::option::Option::Some(v);
    }

    // optional bool enabled = 2;

    pub fn enabled(&self) -> bool {
        self.enabled.unwrap_or(false)
    }

    pub fn clear_enabled(&mut self) {
        self.enabled = ::std::option::Option::None;
    }

    pub fn has_enabled(&self) -> bool {
        self.enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_PerGameSettings {
    const NAME: &'static str = "CGameRecording_PerGameSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.gameid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gameid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.enabled {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.gameid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.enabled {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_PerGameSettings {
        CGameRecording_PerGameSettings::new()
    }

    fn clear(&mut self) {
        self.gameid = ::std::option::Option::None;
        self.enabled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_PerGameSettings {
        static instance: CGameRecording_PerGameSettings = CGameRecording_PerGameSettings {
            gameid: ::std::option::Option::None,
            enabled: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_GetPerGameSettings_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_GetPerGameSettings_Request {
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_GetPerGameSettings_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_GetPerGameSettings_Request {
    fn default() -> &'a CGameRecording_GetPerGameSettings_Request {
        <CGameRecording_GetPerGameSettings_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_GetPerGameSettings_Request {
    pub fn new() -> CGameRecording_GetPerGameSettings_Request {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_GetPerGameSettings_Request {
    const NAME: &'static str = "CGameRecording_GetPerGameSettings_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_GetPerGameSettings_Request {
        CGameRecording_GetPerGameSettings_Request::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_GetPerGameSettings_Request {
        static instance: CGameRecording_GetPerGameSettings_Request = CGameRecording_GetPerGameSettings_Request {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_GetPerGameSettings_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_GetPerGameSettings_Response {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_GetPerGameSettings_Response.settings)
    pub settings: ::std::vec::Vec<CGameRecording_PerGameSettings>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_GetPerGameSettings_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_GetPerGameSettings_Response {
    fn default() -> &'a CGameRecording_GetPerGameSettings_Response {
        <CGameRecording_GetPerGameSettings_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_GetPerGameSettings_Response {
    pub fn new() -> CGameRecording_GetPerGameSettings_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_GetPerGameSettings_Response {
    const NAME: &'static str = "CGameRecording_GetPerGameSettings_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.settings.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.settings {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.settings {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_GetPerGameSettings_Response {
        CGameRecording_GetPerGameSettings_Response::new()
    }

    fn clear(&mut self) {
        self.settings.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_GetPerGameSettings_Response {
        static instance: CGameRecording_GetPerGameSettings_Response = CGameRecording_GetPerGameSettings_Response {
            settings: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_SetPerGameSettings_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_SetPerGameSettings_Request {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_SetPerGameSettings_Request.game_settings)
    pub game_settings: ::steam_vent_proto_common::protobuf::MessageField<CGameRecording_PerGameSettings>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_SetPerGameSettings_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_SetPerGameSettings_Request {
    fn default() -> &'a CGameRecording_SetPerGameSettings_Request {
        <CGameRecording_SetPerGameSettings_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_SetPerGameSettings_Request {
    pub fn new() -> CGameRecording_SetPerGameSettings_Request {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_SetPerGameSettings_Request {
    const NAME: &'static str = "CGameRecording_SetPerGameSettings_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.game_settings)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.game_settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.game_settings.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_SetPerGameSettings_Request {
        CGameRecording_SetPerGameSettings_Request::new()
    }

    fn clear(&mut self) {
        self.game_settings.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_SetPerGameSettings_Request {
        static instance: CGameRecording_SetPerGameSettings_Request = CGameRecording_SetPerGameSettings_Request {
            game_settings: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_SetPerGameSettings_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_SetPerGameSettings_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_SetPerGameSettings_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_SetPerGameSettings_Response {
    fn default() -> &'a CGameRecording_SetPerGameSettings_Response {
        <CGameRecording_SetPerGameSettings_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_SetPerGameSettings_Response {
    pub fn new() -> CGameRecording_SetPerGameSettings_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_SetPerGameSettings_Response {
    const NAME: &'static str = "CGameRecording_SetPerGameSettings_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_SetPerGameSettings_Response {
        CGameRecording_SetPerGameSettings_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_SetPerGameSettings_Response {
        static instance: CGameRecording_SetPerGameSettings_Response = CGameRecording_SetPerGameSettings_Response {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_UploadProgress_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_UploadProgress_Notification {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_UploadProgress_Notification.progress)
    pub progress: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CGameRecording_UploadProgress_Notification.clip_id)
    pub clip_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameRecording_UploadProgress_Notification.eresult)
    pub eresult: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_UploadProgress_Notification.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_UploadProgress_Notification {
    fn default() -> &'a CGameRecording_UploadProgress_Notification {
        <CGameRecording_UploadProgress_Notification as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_UploadProgress_Notification {
    pub fn new() -> CGameRecording_UploadProgress_Notification {
        ::std::default::Default::default()
    }

    // optional float progress = 1;

    pub fn progress(&self) -> f32 {
        self.progress.unwrap_or(0.)
    }

    pub fn clear_progress(&mut self) {
        self.progress = ::std::option::Option::None;
    }

    pub fn has_progress(&self) -> bool {
        self.progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_progress(&mut self, v: f32) {
        self.progress = ::std::option::Option::Some(v);
    }

    // optional string clip_id = 2;

    pub fn clip_id(&self) -> &str {
        match self.clip_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_clip_id(&mut self) {
        self.clip_id = ::std::option::Option::None;
    }

    pub fn has_clip_id(&self) -> bool {
        self.clip_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clip_id(&mut self, v: ::std::string::String) {
        self.clip_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clip_id(&mut self) -> &mut ::std::string::String {
        if self.clip_id.is_none() {
            self.clip_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.clip_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_clip_id(&mut self) -> ::std::string::String {
        self.clip_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 eresult = 3;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(0)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_UploadProgress_Notification {
    const NAME: &'static str = "CGameRecording_UploadProgress_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.progress = ::std::option::Option::Some(is.read_float()?);
                },
                18 => {
                    self.clip_id = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.progress {
            my_size += 1 + 4;
        }
        if let Some(v) = self.clip_id.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.eresult {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.progress {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.clip_id.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_UploadProgress_Notification {
        CGameRecording_UploadProgress_Notification::new()
    }

    fn clear(&mut self) {
        self.progress = ::std::option::Option::None;
        self.clip_id = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_UploadProgress_Notification {
        static instance: CGameRecording_UploadProgress_Notification = CGameRecording_UploadProgress_Notification {
            progress: ::std::option::Option::None,
            clip_id: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_SwitchBackgroundRecordingGame_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_SwitchBackgroundRecordingGame_Request {
    // message fields
    // @@protoc_insertion_point(field:CGameRecording_SwitchBackgroundRecordingGame_Request.game_id)
    pub game_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_SwitchBackgroundRecordingGame_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_SwitchBackgroundRecordingGame_Request {
    fn default() -> &'a CGameRecording_SwitchBackgroundRecordingGame_Request {
        <CGameRecording_SwitchBackgroundRecordingGame_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_SwitchBackgroundRecordingGame_Request {
    pub fn new() -> CGameRecording_SwitchBackgroundRecordingGame_Request {
        ::std::default::Default::default()
    }

    // optional uint64 game_id = 1;

    pub fn game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_SwitchBackgroundRecordingGame_Request {
    const NAME: &'static str = "CGameRecording_SwitchBackgroundRecordingGame_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.game_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.game_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.game_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_SwitchBackgroundRecordingGame_Request {
        CGameRecording_SwitchBackgroundRecordingGame_Request::new()
    }

    fn clear(&mut self) {
        self.game_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_SwitchBackgroundRecordingGame_Request {
        static instance: CGameRecording_SwitchBackgroundRecordingGame_Request = CGameRecording_SwitchBackgroundRecordingGame_Request {
            game_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecording_SwitchBackgroundRecordingGame_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecording_SwitchBackgroundRecordingGame_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecording_SwitchBackgroundRecordingGame_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecording_SwitchBackgroundRecordingGame_Response {
    fn default() -> &'a CGameRecording_SwitchBackgroundRecordingGame_Response {
        <CGameRecording_SwitchBackgroundRecordingGame_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecording_SwitchBackgroundRecordingGame_Response {
    pub fn new() -> CGameRecording_SwitchBackgroundRecordingGame_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecording_SwitchBackgroundRecordingGame_Response {
    const NAME: &'static str = "CGameRecording_SwitchBackgroundRecordingGame_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecording_SwitchBackgroundRecordingGame_Response {
        CGameRecording_SwitchBackgroundRecordingGame_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecording_SwitchBackgroundRecordingGame_Response {
        static instance: CGameRecording_SwitchBackgroundRecordingGame_Response = CGameRecording_SwitchBackgroundRecordingGame_Response {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecordingDebug_AddTimelineHighlightMarker_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecordingDebug_AddTimelineHighlightMarker_Request {
    // message fields
    // @@protoc_insertion_point(field:CGameRecordingDebug_AddTimelineHighlightMarker_Request.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGameRecordingDebug_AddTimelineHighlightMarker_Request.icon)
    pub icon: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameRecordingDebug_AddTimelineHighlightMarker_Request.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameRecordingDebug_AddTimelineHighlightMarker_Request.desc)
    pub desc: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecordingDebug_AddTimelineHighlightMarker_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecordingDebug_AddTimelineHighlightMarker_Request {
    fn default() -> &'a CGameRecordingDebug_AddTimelineHighlightMarker_Request {
        <CGameRecordingDebug_AddTimelineHighlightMarker_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecordingDebug_AddTimelineHighlightMarker_Request {
    pub fn new() -> CGameRecordingDebug_AddTimelineHighlightMarker_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string icon = 2;

    pub fn icon(&self) -> &str {
        match self.icon.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_icon(&mut self) {
        self.icon = ::std::option::Option::None;
    }

    pub fn has_icon(&self) -> bool {
        self.icon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_icon(&mut self, v: ::std::string::String) {
        self.icon = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon(&mut self) -> &mut ::std::string::String {
        if self.icon.is_none() {
            self.icon = ::std::option::Option::Some(::std::string::String::new());
        }
        self.icon.as_mut().unwrap()
    }

    // Take field
    pub fn take_icon(&mut self) -> ::std::string::String {
        self.icon.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string title = 3;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string desc = 4;

    pub fn desc(&self) -> &str {
        match self.desc.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_desc(&mut self) {
        self.desc = ::std::option::Option::None;
    }

    pub fn has_desc(&self) -> bool {
        self.desc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desc(&mut self, v: ::std::string::String) {
        self.desc = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desc(&mut self) -> &mut ::std::string::String {
        if self.desc.is_none() {
            self.desc = ::std::option::Option::Some(::std::string::String::new());
        }
        self.desc.as_mut().unwrap()
    }

    // Take field
    pub fn take_desc(&mut self) -> ::std::string::String {
        self.desc.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecordingDebug_AddTimelineHighlightMarker_Request {
    const NAME: &'static str = "CGameRecordingDebug_AddTimelineHighlightMarker_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.icon = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.desc = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.icon.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.desc.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.icon.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.desc.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecordingDebug_AddTimelineHighlightMarker_Request {
        CGameRecordingDebug_AddTimelineHighlightMarker_Request::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.icon = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.desc = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecordingDebug_AddTimelineHighlightMarker_Request {
        static instance: CGameRecordingDebug_AddTimelineHighlightMarker_Request = CGameRecordingDebug_AddTimelineHighlightMarker_Request {
            appid: ::std::option::Option::None,
            icon: ::std::option::Option::None,
            title: ::std::option::Option::None,
            desc: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecordingDebug_AddTimelineHighlightMarker_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecordingDebug_AddTimelineHighlightMarker_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecordingDebug_AddTimelineHighlightMarker_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecordingDebug_AddTimelineHighlightMarker_Response {
    fn default() -> &'a CGameRecordingDebug_AddTimelineHighlightMarker_Response {
        <CGameRecordingDebug_AddTimelineHighlightMarker_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecordingDebug_AddTimelineHighlightMarker_Response {
    pub fn new() -> CGameRecordingDebug_AddTimelineHighlightMarker_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecordingDebug_AddTimelineHighlightMarker_Response {
    const NAME: &'static str = "CGameRecordingDebug_AddTimelineHighlightMarker_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecordingDebug_AddTimelineHighlightMarker_Response {
        CGameRecordingDebug_AddTimelineHighlightMarker_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecordingDebug_AddTimelineHighlightMarker_Response {
        static instance: CGameRecordingDebug_AddTimelineHighlightMarker_Response = CGameRecordingDebug_AddTimelineHighlightMarker_Response {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecordingDebug_AddTimelineTimestamp_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecordingDebug_AddTimelineTimestamp_Request {
    // message fields
    // @@protoc_insertion_point(field:CGameRecordingDebug_AddTimelineTimestamp_Request.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGameRecordingDebug_AddTimelineTimestamp_Request.title)
    pub title: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecordingDebug_AddTimelineTimestamp_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecordingDebug_AddTimelineTimestamp_Request {
    fn default() -> &'a CGameRecordingDebug_AddTimelineTimestamp_Request {
        <CGameRecordingDebug_AddTimelineTimestamp_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecordingDebug_AddTimelineTimestamp_Request {
    pub fn new() -> CGameRecordingDebug_AddTimelineTimestamp_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string title = 2;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecordingDebug_AddTimelineTimestamp_Request {
    const NAME: &'static str = "CGameRecordingDebug_AddTimelineTimestamp_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecordingDebug_AddTimelineTimestamp_Request {
        CGameRecordingDebug_AddTimelineTimestamp_Request::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecordingDebug_AddTimelineTimestamp_Request {
        static instance: CGameRecordingDebug_AddTimelineTimestamp_Request = CGameRecordingDebug_AddTimelineTimestamp_Request {
            appid: ::std::option::Option::None,
            title: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecordingDebug_AddTimelineTimestamp_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecordingDebug_AddTimelineTimestamp_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecordingDebug_AddTimelineTimestamp_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecordingDebug_AddTimelineTimestamp_Response {
    fn default() -> &'a CGameRecordingDebug_AddTimelineTimestamp_Response {
        <CGameRecordingDebug_AddTimelineTimestamp_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecordingDebug_AddTimelineTimestamp_Response {
    pub fn new() -> CGameRecordingDebug_AddTimelineTimestamp_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecordingDebug_AddTimelineTimestamp_Response {
    const NAME: &'static str = "CGameRecordingDebug_AddTimelineTimestamp_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecordingDebug_AddTimelineTimestamp_Response {
        CGameRecordingDebug_AddTimelineTimestamp_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecordingDebug_AddTimelineTimestamp_Response {
        static instance: CGameRecordingDebug_AddTimelineTimestamp_Response = CGameRecordingDebug_AddTimelineTimestamp_Response {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecordingDebug_AddTimelineRangeStart_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecordingDebug_AddTimelineRangeStart_Request {
    // message fields
    // @@protoc_insertion_point(field:CGameRecordingDebug_AddTimelineRangeStart_Request.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGameRecordingDebug_AddTimelineRangeStart_Request.id)
    pub id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameRecordingDebug_AddTimelineRangeStart_Request.title)
    pub title: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecordingDebug_AddTimelineRangeStart_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecordingDebug_AddTimelineRangeStart_Request {
    fn default() -> &'a CGameRecordingDebug_AddTimelineRangeStart_Request {
        <CGameRecordingDebug_AddTimelineRangeStart_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecordingDebug_AddTimelineRangeStart_Request {
    pub fn new() -> CGameRecordingDebug_AddTimelineRangeStart_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string id = 2;

    pub fn id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string title = 3;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecordingDebug_AddTimelineRangeStart_Request {
    const NAME: &'static str = "CGameRecordingDebug_AddTimelineRangeStart_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.id = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.id.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.id.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecordingDebug_AddTimelineRangeStart_Request {
        CGameRecordingDebug_AddTimelineRangeStart_Request::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.id = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecordingDebug_AddTimelineRangeStart_Request {
        static instance: CGameRecordingDebug_AddTimelineRangeStart_Request = CGameRecordingDebug_AddTimelineRangeStart_Request {
            appid: ::std::option::Option::None,
            id: ::std::option::Option::None,
            title: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecordingDebug_AddTimelineRangeStart_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecordingDebug_AddTimelineRangeStart_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecordingDebug_AddTimelineRangeStart_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecordingDebug_AddTimelineRangeStart_Response {
    fn default() -> &'a CGameRecordingDebug_AddTimelineRangeStart_Response {
        <CGameRecordingDebug_AddTimelineRangeStart_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecordingDebug_AddTimelineRangeStart_Response {
    pub fn new() -> CGameRecordingDebug_AddTimelineRangeStart_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecordingDebug_AddTimelineRangeStart_Response {
    const NAME: &'static str = "CGameRecordingDebug_AddTimelineRangeStart_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecordingDebug_AddTimelineRangeStart_Response {
        CGameRecordingDebug_AddTimelineRangeStart_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecordingDebug_AddTimelineRangeStart_Response {
        static instance: CGameRecordingDebug_AddTimelineRangeStart_Response = CGameRecordingDebug_AddTimelineRangeStart_Response {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecordingDebug_AddTimelineRangeEnd_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecordingDebug_AddTimelineRangeEnd_Request {
    // message fields
    // @@protoc_insertion_point(field:CGameRecordingDebug_AddTimelineRangeEnd_Request.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGameRecordingDebug_AddTimelineRangeEnd_Request.id)
    pub id: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecordingDebug_AddTimelineRangeEnd_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecordingDebug_AddTimelineRangeEnd_Request {
    fn default() -> &'a CGameRecordingDebug_AddTimelineRangeEnd_Request {
        <CGameRecordingDebug_AddTimelineRangeEnd_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecordingDebug_AddTimelineRangeEnd_Request {
    pub fn new() -> CGameRecordingDebug_AddTimelineRangeEnd_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string id = 2;

    pub fn id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecordingDebug_AddTimelineRangeEnd_Request {
    const NAME: &'static str = "CGameRecordingDebug_AddTimelineRangeEnd_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.id = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.id.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.id.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecordingDebug_AddTimelineRangeEnd_Request {
        CGameRecordingDebug_AddTimelineRangeEnd_Request::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecordingDebug_AddTimelineRangeEnd_Request {
        static instance: CGameRecordingDebug_AddTimelineRangeEnd_Request = CGameRecordingDebug_AddTimelineRangeEnd_Request {
            appid: ::std::option::Option::None,
            id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecordingDebug_AddTimelineRangeEnd_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecordingDebug_AddTimelineRangeEnd_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecordingDebug_AddTimelineRangeEnd_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecordingDebug_AddTimelineRangeEnd_Response {
    fn default() -> &'a CGameRecordingDebug_AddTimelineRangeEnd_Response {
        <CGameRecordingDebug_AddTimelineRangeEnd_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecordingDebug_AddTimelineRangeEnd_Response {
    pub fn new() -> CGameRecordingDebug_AddTimelineRangeEnd_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecordingDebug_AddTimelineRangeEnd_Response {
    const NAME: &'static str = "CGameRecordingDebug_AddTimelineRangeEnd_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecordingDebug_AddTimelineRangeEnd_Response {
        CGameRecordingDebug_AddTimelineRangeEnd_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecordingDebug_AddTimelineRangeEnd_Response {
        static instance: CGameRecordingDebug_AddTimelineRangeEnd_Response = CGameRecordingDebug_AddTimelineRangeEnd_Response {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecordingDebug_SetTimelineGameMode_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecordingDebug_SetTimelineGameMode_Request {
    // message fields
    // @@protoc_insertion_point(field:CGameRecordingDebug_SetTimelineGameMode_Request.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGameRecordingDebug_SetTimelineGameMode_Request.mode)
    pub mode: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecordingDebug_SetTimelineGameMode_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecordingDebug_SetTimelineGameMode_Request {
    fn default() -> &'a CGameRecordingDebug_SetTimelineGameMode_Request {
        <CGameRecordingDebug_SetTimelineGameMode_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecordingDebug_SetTimelineGameMode_Request {
    pub fn new() -> CGameRecordingDebug_SetTimelineGameMode_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 mode = 2;

    pub fn mode(&self) -> u32 {
        self.mode.unwrap_or(0)
    }

    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: u32) {
        self.mode = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecordingDebug_SetTimelineGameMode_Request {
    const NAME: &'static str = "CGameRecordingDebug_SetTimelineGameMode_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.mode = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.mode {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.mode {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecordingDebug_SetTimelineGameMode_Request {
        CGameRecordingDebug_SetTimelineGameMode_Request::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.mode = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecordingDebug_SetTimelineGameMode_Request {
        static instance: CGameRecordingDebug_SetTimelineGameMode_Request = CGameRecordingDebug_SetTimelineGameMode_Request {
            appid: ::std::option::Option::None,
            mode: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameRecordingDebug_SetTimelineGameMode_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameRecordingDebug_SetTimelineGameMode_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CGameRecordingDebug_SetTimelineGameMode_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameRecordingDebug_SetTimelineGameMode_Response {
    fn default() -> &'a CGameRecordingDebug_SetTimelineGameMode_Response {
        <CGameRecordingDebug_SetTimelineGameMode_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameRecordingDebug_SetTimelineGameMode_Response {
    pub fn new() -> CGameRecordingDebug_SetTimelineGameMode_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameRecordingDebug_SetTimelineGameMode_Response {
    const NAME: &'static str = "CGameRecordingDebug_SetTimelineGameMode_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameRecordingDebug_SetTimelineGameMode_Response {
        CGameRecordingDebug_SetTimelineGameMode_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameRecordingDebug_SetTimelineGameMode_Response {
        static instance: CGameRecordingDebug_SetTimelineGameMode_Response = CGameRecordingDebug_SetTimelineGameMode_Response {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ETimelineEntryType)
pub enum ETimelineEntryType {
    // @@protoc_insertion_point(enum_value:ETimelineEntryType.k_ETimelineEntryType_Invalid)
    k_ETimelineEntryType_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ETimelineEntryType.k_ETimelineEntryType_GameMode)
    k_ETimelineEntryType_GameMode = 1,
    // @@protoc_insertion_point(enum_value:ETimelineEntryType.k_ETimelineEntryType_Event)
    k_ETimelineEntryType_Event = 2,
    // @@protoc_insertion_point(enum_value:ETimelineEntryType.k_ETimelineEntryType_StateDescription)
    k_ETimelineEntryType_StateDescription = 3,
    // @@protoc_insertion_point(enum_value:ETimelineEntryType.k_ETimelineEntryType_Achievement)
    k_ETimelineEntryType_Achievement = 4,
    // @@protoc_insertion_point(enum_value:ETimelineEntryType.k_ETimelineEntryType_UserMarker)
    k_ETimelineEntryType_UserMarker = 5,
    // @@protoc_insertion_point(enum_value:ETimelineEntryType.k_ETimelineEntryType_Screenshot)
    k_ETimelineEntryType_Screenshot = 6,
    // @@protoc_insertion_point(enum_value:ETimelineEntryType.k_ETimelineEntryType_Error)
    k_ETimelineEntryType_Error = 7,
    // @@protoc_insertion_point(enum_value:ETimelineEntryType.k_ETimelineEntryType_Tag)
    k_ETimelineEntryType_Tag = 8,
    // @@protoc_insertion_point(enum_value:ETimelineEntryType.k_ETimelineEntryType_GamePhase)
    k_ETimelineEntryType_GamePhase = 9,
}

impl ::steam_vent_proto_common::protobuf::Enum for ETimelineEntryType {
    const NAME: &'static str = "ETimelineEntryType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ETimelineEntryType> {
        match value {
            0 => ::std::option::Option::Some(ETimelineEntryType::k_ETimelineEntryType_Invalid),
            1 => ::std::option::Option::Some(ETimelineEntryType::k_ETimelineEntryType_GameMode),
            2 => ::std::option::Option::Some(ETimelineEntryType::k_ETimelineEntryType_Event),
            3 => ::std::option::Option::Some(ETimelineEntryType::k_ETimelineEntryType_StateDescription),
            4 => ::std::option::Option::Some(ETimelineEntryType::k_ETimelineEntryType_Achievement),
            5 => ::std::option::Option::Some(ETimelineEntryType::k_ETimelineEntryType_UserMarker),
            6 => ::std::option::Option::Some(ETimelineEntryType::k_ETimelineEntryType_Screenshot),
            7 => ::std::option::Option::Some(ETimelineEntryType::k_ETimelineEntryType_Error),
            8 => ::std::option::Option::Some(ETimelineEntryType::k_ETimelineEntryType_Tag),
            9 => ::std::option::Option::Some(ETimelineEntryType::k_ETimelineEntryType_GamePhase),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ETimelineEntryType> {
        match str {
            "k_ETimelineEntryType_Invalid" => ::std::option::Option::Some(ETimelineEntryType::k_ETimelineEntryType_Invalid),
            "k_ETimelineEntryType_GameMode" => ::std::option::Option::Some(ETimelineEntryType::k_ETimelineEntryType_GameMode),
            "k_ETimelineEntryType_Event" => ::std::option::Option::Some(ETimelineEntryType::k_ETimelineEntryType_Event),
            "k_ETimelineEntryType_StateDescription" => ::std::option::Option::Some(ETimelineEntryType::k_ETimelineEntryType_StateDescription),
            "k_ETimelineEntryType_Achievement" => ::std::option::Option::Some(ETimelineEntryType::k_ETimelineEntryType_Achievement),
            "k_ETimelineEntryType_UserMarker" => ::std::option::Option::Some(ETimelineEntryType::k_ETimelineEntryType_UserMarker),
            "k_ETimelineEntryType_Screenshot" => ::std::option::Option::Some(ETimelineEntryType::k_ETimelineEntryType_Screenshot),
            "k_ETimelineEntryType_Error" => ::std::option::Option::Some(ETimelineEntryType::k_ETimelineEntryType_Error),
            "k_ETimelineEntryType_Tag" => ::std::option::Option::Some(ETimelineEntryType::k_ETimelineEntryType_Tag),
            "k_ETimelineEntryType_GamePhase" => ::std::option::Option::Some(ETimelineEntryType::k_ETimelineEntryType_GamePhase),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ETimelineEntryType] = &[
        ETimelineEntryType::k_ETimelineEntryType_Invalid,
        ETimelineEntryType::k_ETimelineEntryType_GameMode,
        ETimelineEntryType::k_ETimelineEntryType_Event,
        ETimelineEntryType::k_ETimelineEntryType_StateDescription,
        ETimelineEntryType::k_ETimelineEntryType_Achievement,
        ETimelineEntryType::k_ETimelineEntryType_UserMarker,
        ETimelineEntryType::k_ETimelineEntryType_Screenshot,
        ETimelineEntryType::k_ETimelineEntryType_Error,
        ETimelineEntryType::k_ETimelineEntryType_Tag,
        ETimelineEntryType::k_ETimelineEntryType_GamePhase,
    ];
}

impl ::std::default::Default for ETimelineEntryType {
    fn default() -> Self {
        ETimelineEntryType::k_ETimelineEntryType_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EPhaseResultType)
pub enum EPhaseResultType {
    // @@protoc_insertion_point(enum_value:EPhaseResultType.k_EPhaseResultType_Automatic)
    k_EPhaseResultType_Automatic = 1,
    // @@protoc_insertion_point(enum_value:EPhaseResultType.k_EPhaseResultType_Blank)
    k_EPhaseResultType_Blank = 2,
    // @@protoc_insertion_point(enum_value:EPhaseResultType.k_EPhaseResultType_API)
    k_EPhaseResultType_API = 3,
}

impl ::steam_vent_proto_common::protobuf::Enum for EPhaseResultType {
    const NAME: &'static str = "EPhaseResultType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EPhaseResultType> {
        match value {
            1 => ::std::option::Option::Some(EPhaseResultType::k_EPhaseResultType_Automatic),
            2 => ::std::option::Option::Some(EPhaseResultType::k_EPhaseResultType_Blank),
            3 => ::std::option::Option::Some(EPhaseResultType::k_EPhaseResultType_API),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EPhaseResultType> {
        match str {
            "k_EPhaseResultType_Automatic" => ::std::option::Option::Some(EPhaseResultType::k_EPhaseResultType_Automatic),
            "k_EPhaseResultType_Blank" => ::std::option::Option::Some(EPhaseResultType::k_EPhaseResultType_Blank),
            "k_EPhaseResultType_API" => ::std::option::Option::Some(EPhaseResultType::k_EPhaseResultType_API),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EPhaseResultType] = &[
        EPhaseResultType::k_EPhaseResultType_Automatic,
        EPhaseResultType::k_EPhaseResultType_Blank,
        EPhaseResultType::k_EPhaseResultType_API,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EPhaseResultType {
    fn default() -> Self {
        EPhaseResultType::k_EPhaseResultType_Automatic
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ETimelineChangeNotificationType)
pub enum ETimelineChangeNotificationType {
    // @@protoc_insertion_point(enum_value:ETimelineChangeNotificationType.k_ETimelineChangeNotificationType_Started)
    k_ETimelineChangeNotificationType_Started = 1,
    // @@protoc_insertion_point(enum_value:ETimelineChangeNotificationType.k_ETimelineChangeNotificationType_Stopped)
    k_ETimelineChangeNotificationType_Stopped = 2,
    // @@protoc_insertion_point(enum_value:ETimelineChangeNotificationType.k_ETimelineChangeNotificationType_Deleted)
    k_ETimelineChangeNotificationType_Deleted = 3,
    // @@protoc_insertion_point(enum_value:ETimelineChangeNotificationType.k_ETimelineChangeNotificationType_RecordingStarted)
    k_ETimelineChangeNotificationType_RecordingStarted = 4,
    // @@protoc_insertion_point(enum_value:ETimelineChangeNotificationType.k_ETimelineChangeNotificationType_RecordingStopped)
    k_ETimelineChangeNotificationType_RecordingStopped = 5,
    // @@protoc_insertion_point(enum_value:ETimelineChangeNotificationType.k_ETimelineChangeNotificationType_RecordingUpdated)
    k_ETimelineChangeNotificationType_RecordingUpdated = 6,
}

impl ::steam_vent_proto_common::protobuf::Enum for ETimelineChangeNotificationType {
    const NAME: &'static str = "ETimelineChangeNotificationType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ETimelineChangeNotificationType> {
        match value {
            1 => ::std::option::Option::Some(ETimelineChangeNotificationType::k_ETimelineChangeNotificationType_Started),
            2 => ::std::option::Option::Some(ETimelineChangeNotificationType::k_ETimelineChangeNotificationType_Stopped),
            3 => ::std::option::Option::Some(ETimelineChangeNotificationType::k_ETimelineChangeNotificationType_Deleted),
            4 => ::std::option::Option::Some(ETimelineChangeNotificationType::k_ETimelineChangeNotificationType_RecordingStarted),
            5 => ::std::option::Option::Some(ETimelineChangeNotificationType::k_ETimelineChangeNotificationType_RecordingStopped),
            6 => ::std::option::Option::Some(ETimelineChangeNotificationType::k_ETimelineChangeNotificationType_RecordingUpdated),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ETimelineChangeNotificationType> {
        match str {
            "k_ETimelineChangeNotificationType_Started" => ::std::option::Option::Some(ETimelineChangeNotificationType::k_ETimelineChangeNotificationType_Started),
            "k_ETimelineChangeNotificationType_Stopped" => ::std::option::Option::Some(ETimelineChangeNotificationType::k_ETimelineChangeNotificationType_Stopped),
            "k_ETimelineChangeNotificationType_Deleted" => ::std::option::Option::Some(ETimelineChangeNotificationType::k_ETimelineChangeNotificationType_Deleted),
            "k_ETimelineChangeNotificationType_RecordingStarted" => ::std::option::Option::Some(ETimelineChangeNotificationType::k_ETimelineChangeNotificationType_RecordingStarted),
            "k_ETimelineChangeNotificationType_RecordingStopped" => ::std::option::Option::Some(ETimelineChangeNotificationType::k_ETimelineChangeNotificationType_RecordingStopped),
            "k_ETimelineChangeNotificationType_RecordingUpdated" => ::std::option::Option::Some(ETimelineChangeNotificationType::k_ETimelineChangeNotificationType_RecordingUpdated),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ETimelineChangeNotificationType] = &[
        ETimelineChangeNotificationType::k_ETimelineChangeNotificationType_Started,
        ETimelineChangeNotificationType::k_ETimelineChangeNotificationType_Stopped,
        ETimelineChangeNotificationType::k_ETimelineChangeNotificationType_Deleted,
        ETimelineChangeNotificationType::k_ETimelineChangeNotificationType_RecordingStarted,
        ETimelineChangeNotificationType::k_ETimelineChangeNotificationType_RecordingStopped,
        ETimelineChangeNotificationType::k_ETimelineChangeNotificationType_RecordingUpdated,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ETimelineChangeNotificationType {
    fn default() -> Self {
        ETimelineChangeNotificationType::k_ETimelineChangeNotificationType_Started
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ERecordingSessionChangeNotificationType)
pub enum ERecordingSessionChangeNotificationType {
    // @@protoc_insertion_point(enum_value:ERecordingSessionChangeNotificationType.k_ERecordingSessionChangeNotificationType_Started)
    k_ERecordingSessionChangeNotificationType_Started = 1,
    // @@protoc_insertion_point(enum_value:ERecordingSessionChangeNotificationType.k_ERecordingSessionChangeNotificationType_Stopped)
    k_ERecordingSessionChangeNotificationType_Stopped = 2,
    // @@protoc_insertion_point(enum_value:ERecordingSessionChangeNotificationType.k_ERecordingSessionChangeNotificationType_Deleted)
    k_ERecordingSessionChangeNotificationType_Deleted = 3,
    // @@protoc_insertion_point(enum_value:ERecordingSessionChangeNotificationType.k_ERecordingSessionChangeNotificationType_Updated)
    k_ERecordingSessionChangeNotificationType_Updated = 4,
}

impl ::steam_vent_proto_common::protobuf::Enum for ERecordingSessionChangeNotificationType {
    const NAME: &'static str = "ERecordingSessionChangeNotificationType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ERecordingSessionChangeNotificationType> {
        match value {
            1 => ::std::option::Option::Some(ERecordingSessionChangeNotificationType::k_ERecordingSessionChangeNotificationType_Started),
            2 => ::std::option::Option::Some(ERecordingSessionChangeNotificationType::k_ERecordingSessionChangeNotificationType_Stopped),
            3 => ::std::option::Option::Some(ERecordingSessionChangeNotificationType::k_ERecordingSessionChangeNotificationType_Deleted),
            4 => ::std::option::Option::Some(ERecordingSessionChangeNotificationType::k_ERecordingSessionChangeNotificationType_Updated),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ERecordingSessionChangeNotificationType> {
        match str {
            "k_ERecordingSessionChangeNotificationType_Started" => ::std::option::Option::Some(ERecordingSessionChangeNotificationType::k_ERecordingSessionChangeNotificationType_Started),
            "k_ERecordingSessionChangeNotificationType_Stopped" => ::std::option::Option::Some(ERecordingSessionChangeNotificationType::k_ERecordingSessionChangeNotificationType_Stopped),
            "k_ERecordingSessionChangeNotificationType_Deleted" => ::std::option::Option::Some(ERecordingSessionChangeNotificationType::k_ERecordingSessionChangeNotificationType_Deleted),
            "k_ERecordingSessionChangeNotificationType_Updated" => ::std::option::Option::Some(ERecordingSessionChangeNotificationType::k_ERecordingSessionChangeNotificationType_Updated),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ERecordingSessionChangeNotificationType] = &[
        ERecordingSessionChangeNotificationType::k_ERecordingSessionChangeNotificationType_Started,
        ERecordingSessionChangeNotificationType::k_ERecordingSessionChangeNotificationType_Stopped,
        ERecordingSessionChangeNotificationType::k_ERecordingSessionChangeNotificationType_Deleted,
        ERecordingSessionChangeNotificationType::k_ERecordingSessionChangeNotificationType_Updated,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ERecordingSessionChangeNotificationType {
    fn default() -> Self {
        ERecordingSessionChangeNotificationType::k_ERecordingSessionChangeNotificationType_Started
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EDiskSpaceType)
pub enum EDiskSpaceType {
    // @@protoc_insertion_point(enum_value:EDiskSpaceType.k_eDiskSpaceType_Recording)
    k_eDiskSpaceType_Recording = 0,
    // @@protoc_insertion_point(enum_value:EDiskSpaceType.k_eDiskSpaceType_Clip)
    k_eDiskSpaceType_Clip = 1,
}

impl ::steam_vent_proto_common::protobuf::Enum for EDiskSpaceType {
    const NAME: &'static str = "EDiskSpaceType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EDiskSpaceType> {
        match value {
            0 => ::std::option::Option::Some(EDiskSpaceType::k_eDiskSpaceType_Recording),
            1 => ::std::option::Option::Some(EDiskSpaceType::k_eDiskSpaceType_Clip),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EDiskSpaceType> {
        match str {
            "k_eDiskSpaceType_Recording" => ::std::option::Option::Some(EDiskSpaceType::k_eDiskSpaceType_Recording),
            "k_eDiskSpaceType_Clip" => ::std::option::Option::Some(EDiskSpaceType::k_eDiskSpaceType_Clip),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EDiskSpaceType] = &[
        EDiskSpaceType::k_eDiskSpaceType_Recording,
        EDiskSpaceType::k_eDiskSpaceType_Clip,
    ];
}

impl ::std::default::Default for EDiskSpaceType {
    fn default() -> Self {
        EDiskSpaceType::k_eDiskSpaceType_Recording
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EThumbnailTimePrecision)
pub enum EThumbnailTimePrecision {
    // @@protoc_insertion_point(enum_value:EThumbnailTimePrecision.k_ePrecise)
    k_ePrecise = 0,
    // @@protoc_insertion_point(enum_value:EThumbnailTimePrecision.k_eLoose)
    k_eLoose = 1,
}

impl ::steam_vent_proto_common::protobuf::Enum for EThumbnailTimePrecision {
    const NAME: &'static str = "EThumbnailTimePrecision";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EThumbnailTimePrecision> {
        match value {
            0 => ::std::option::Option::Some(EThumbnailTimePrecision::k_ePrecise),
            1 => ::std::option::Option::Some(EThumbnailTimePrecision::k_eLoose),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EThumbnailTimePrecision> {
        match str {
            "k_ePrecise" => ::std::option::Option::Some(EThumbnailTimePrecision::k_ePrecise),
            "k_eLoose" => ::std::option::Option::Some(EThumbnailTimePrecision::k_eLoose),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EThumbnailTimePrecision] = &[
        EThumbnailTimePrecision::k_ePrecise,
        EThumbnailTimePrecision::k_eLoose,
    ];
}

impl ::std::default::Default for EThumbnailTimePrecision {
    fn default() -> Self {
        EThumbnailTimePrecision::k_ePrecise
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EThumbnailFormat)
pub enum EThumbnailFormat {
    // @@protoc_insertion_point(enum_value:EThumbnailFormat.k_eJPEG)
    k_eJPEG = 1,
    // @@protoc_insertion_point(enum_value:EThumbnailFormat.k_eRGB)
    k_eRGB = 2,
}

impl ::steam_vent_proto_common::protobuf::Enum for EThumbnailFormat {
    const NAME: &'static str = "EThumbnailFormat";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EThumbnailFormat> {
        match value {
            1 => ::std::option::Option::Some(EThumbnailFormat::k_eJPEG),
            2 => ::std::option::Option::Some(EThumbnailFormat::k_eRGB),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EThumbnailFormat> {
        match str {
            "k_eJPEG" => ::std::option::Option::Some(EThumbnailFormat::k_eJPEG),
            "k_eRGB" => ::std::option::Option::Some(EThumbnailFormat::k_eRGB),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EThumbnailFormat] = &[
        EThumbnailFormat::k_eJPEG,
        EThumbnailFormat::k_eRGB,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EThumbnailFormat {
    fn default() -> Self {
        EThumbnailFormat::k_eJPEG
    }
}



const _VENT_PROTO_VERSION_CHECK: () = ::steam_vent_proto_common::VERSION_0_5_0;

#[allow(unused_imports)]
use crate::enums::*;
#[allow(unused_imports)]
use crate::steammessages_base::*;
#[allow(unused_imports)]
use crate::webuimessages_base::*;
#[allow(unused_imports)]
use crate::webuimessages_gamerecordingfiles::*;
impl ::steam_vent_proto_common::RpcMessage
for CGameRecording_GetActiveTimelineApps_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CGameRecording_GetActiveTimelineApps_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CGameRecording_GetTimelinesForApp_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CGameRecording_GetTimelinesForApp_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CGameRecording_GetTimelinesForClip_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CGameRecording_GetTimelinesForClip_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGameRecording_QueryPhases_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGameRecording_QueryPhases_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGameRecording_GetTags_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGameRecording_GetTags_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CGameRecording_GetEnoughDiskSpace_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CGameRecording_GetEnoughDiskSpace_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CGameRecording_GetAvailableDiskSpace_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CGameRecording_GetAvailableDiskSpace_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CGameRecording_TimelineChanged_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CGameRecording_RecordingSessionChanged_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CTimelineEntry {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CGameRecording_TimelineEntryChanged_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGameRecording_LowDiskSpace_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CGameRecording_PostGameHighlightsChanged_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGameRecording_ClipSummary {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGameRecording_SaveClip_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGameRecording_SaveClip_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGameRecording_DeleteClip_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGameRecording_DeleteClip_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGameRecording_ExportClip_Settings {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGameRecording_ExportClip_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGameRecording_ExportClip_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGameRecording_TakeScreenshot_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGameRecording_TakeScreenshot_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGameRecording_UploadClipToSteam_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CGameRecording_UploadClipToSteam_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGameRecording_ZipClip_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGameRecording_ZipClip_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGameRecording_GetClips_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGameRecording_GetClips_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CGameRecording_GetAndTrimPostGameHighlights_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CGameRecording_GetAndTrimPostGameHighlights_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CGameRecording_UserAddTimelineEntry_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CGameRecording_UserAddTimelineEntry_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CGameRecording_UserUpdateTimelineEntry_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CGameRecording_UserUpdateTimelineEntry_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CGameRecording_UserRemoveTimelineEntry_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CGameRecording_UserRemoveTimelineEntry_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CGameRecording_ManuallyDeleteRecordingsForApps_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CGameRecording_ManuallyDeleteRecordingsForApps_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CGameRecording_GetTotalDiskSpaceUsage_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CGameRecording_GetTotalDiskSpaceUsage_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGameRecording_GetThumbnails_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGameRecording_GetThumbnails_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGameRecording_StartRecording_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGameRecording_StartRecording_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGameRecording_StopRecording_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGameRecording_StopRecording_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGameRecording_GetRecordingSize_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGameRecording_GetRecordingSize_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CGameRecording_CleanupBackgroundRecordings_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CGameRecording_CleanupBackgroundRecordings_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CGameRecording_GetPlatformCapabilities_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CGameRecording_GetPlatformCapabilities_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGameRecording_ClipCreated_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGameRecording_ClipDeleted_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CGameRecording_ExportProgress_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGameRecording_PerGameSettings {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CGameRecording_GetPerGameSettings_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CGameRecording_GetPerGameSettings_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CGameRecording_SetPerGameSettings_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CGameRecording_SetPerGameSettings_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CGameRecording_UploadProgress_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CGameRecording_SwitchBackgroundRecordingGame_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CGameRecording_SwitchBackgroundRecordingGame_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CGameRecordingDebug_AddTimelineHighlightMarker_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CGameRecordingDebug_AddTimelineHighlightMarker_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CGameRecordingDebug_AddTimelineTimestamp_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CGameRecordingDebug_AddTimelineTimestamp_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CGameRecordingDebug_AddTimelineRangeStart_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CGameRecordingDebug_AddTimelineRangeStart_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CGameRecordingDebug_AddTimelineRangeEnd_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CGameRecordingDebug_AddTimelineRangeEnd_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CGameRecordingDebug_SetTimelineGameMode_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CGameRecordingDebug_SetTimelineGameMode_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
///
struct GameRecording {}
impl ::steam_vent_proto_common::RpcService for GameRecording {
    const SERVICE_NAME: &'static str = "GameRecording";
}
///
struct GameRecordingDebug {}
impl ::steam_vent_proto_common::RpcService for GameRecordingDebug {
    const SERVICE_NAME: &'static str = "GameRecordingDebug";
}
impl ::steam_vent_proto_common::RpcMethod
for CGameRecordingDebug_AddTimelineHighlightMarker_Request {
    const METHOD_NAME: &'static str = "GameRecordingDebug.AddTimelineHighlightMarker#1";
    type Response = CGameRecordingDebug_AddTimelineHighlightMarker_Response;
}
impl ::steam_vent_proto_common::RpcMethod
for CGameRecordingDebug_AddTimelineRangeEnd_Request {
    const METHOD_NAME: &'static str = "GameRecordingDebug.AddTimelineRangeEnd#1";
    type Response = CGameRecordingDebug_AddTimelineRangeEnd_Response;
}
impl ::steam_vent_proto_common::RpcMethod
for CGameRecordingDebug_AddTimelineRangeStart_Request {
    const METHOD_NAME: &'static str = "GameRecordingDebug.AddTimelineRangeStart#1";
    type Response = CGameRecordingDebug_AddTimelineRangeStart_Response;
}
impl ::steam_vent_proto_common::RpcMethod
for CGameRecordingDebug_AddTimelineTimestamp_Request {
    const METHOD_NAME: &'static str = "GameRecordingDebug.AddTimelineTimestamp#1";
    type Response = CGameRecordingDebug_AddTimelineTimestamp_Response;
}
impl ::steam_vent_proto_common::RpcMethod
for CGameRecordingDebug_SetTimelineGameMode_Request {
    const METHOD_NAME: &'static str = "GameRecordingDebug.SetTimelineGameMode#1";
    type Response = CGameRecordingDebug_SetTimelineGameMode_Response;
}
impl ::steam_vent_proto_common::RpcMethod
for CGameRecording_CleanupBackgroundRecordings_Request {
    const METHOD_NAME: &'static str = "GameRecording.CleanupBackgroundRecordings#1";
    type Response = CGameRecording_CleanupBackgroundRecordings_Response;
}
impl ::steam_vent_proto_common::RpcMethod for CGameRecording_ClipCreated_Notification {
    const METHOD_NAME: &'static str = "GameRecording.NotifyClipCreated#1";
    type Response = WebUINoResponse;
}
impl ::steam_vent_proto_common::RpcMethod for CGameRecording_ClipDeleted_Notification {
    const METHOD_NAME: &'static str = "GameRecording.NotifyClipDeleted#1";
    type Response = WebUINoResponse;
}
impl ::steam_vent_proto_common::RpcMethod for CGameRecording_DeleteClip_Request {
    const METHOD_NAME: &'static str = "GameRecording.DeleteClip#1";
    type Response = CGameRecording_DeleteClip_Response;
}
impl ::steam_vent_proto_common::RpcMethod for CGameRecording_ExportClip_Request {
    const METHOD_NAME: &'static str = "GameRecording.ExportClip#1";
    type Response = CGameRecording_ExportClip_Response;
}
impl ::steam_vent_proto_common::RpcMethod
for CGameRecording_ExportProgress_Notification {
    const METHOD_NAME: &'static str = "GameRecording.NotifyExportProgress#1";
    type Response = WebUINoResponse;
}
impl ::steam_vent_proto_common::RpcMethod
for CGameRecording_GetActiveTimelineApps_Request {
    const METHOD_NAME: &'static str = "GameRecording.GetActiveTimelineApps#1";
    type Response = CGameRecording_GetActiveTimelineApps_Response;
}
impl ::steam_vent_proto_common::RpcMethod
for CGameRecording_GetAndTrimPostGameHighlights_Request {
    const METHOD_NAME: &'static str = "GameRecording.GetAndTrimPostGameHighlights#1";
    type Response = CGameRecording_GetAndTrimPostGameHighlights_Response;
}
impl ::steam_vent_proto_common::RpcMethod
for CGameRecording_GetAvailableDiskSpace_Request {
    const METHOD_NAME: &'static str = "GameRecording.GetAvailableDiskSpace#1";
    type Response = CGameRecording_GetAvailableDiskSpace_Response;
}
impl ::steam_vent_proto_common::RpcMethod for CGameRecording_GetClips_Request {
    const METHOD_NAME: &'static str = "GameRecording.GetClips#1";
    type Response = CGameRecording_GetClips_Response;
}
impl ::steam_vent_proto_common::RpcMethod for CGameRecording_GetEnoughDiskSpace_Request {
    const METHOD_NAME: &'static str = "GameRecording.GetEnoughDiskSpace#1";
    type Response = CGameRecording_GetEnoughDiskSpace_Response;
}
impl ::steam_vent_proto_common::RpcMethod for CGameRecording_GetPerGameSettings_Request {
    const METHOD_NAME: &'static str = "GameRecording.GetPerGameSettings#1";
    type Response = CGameRecording_GetPerGameSettings_Response;
}
impl ::steam_vent_proto_common::RpcMethod
for CGameRecording_GetPlatformCapabilities_Request {
    const METHOD_NAME: &'static str = "GameRecording.GetPlatformCapabilities#1";
    type Response = CGameRecording_GetPlatformCapabilities_Response;
}
impl ::steam_vent_proto_common::RpcMethod for CGameRecording_GetRecordingSize_Request {
    const METHOD_NAME: &'static str = "GameRecording.GetBackgroundRecordingFileSize#1";
    type Response = CGameRecording_GetRecordingSize_Response;
}
impl ::steam_vent_proto_common::RpcMethod for CGameRecording_GetTags_Request {
    const METHOD_NAME: &'static str = "GameRecording.GetTags#1";
    type Response = CGameRecording_GetTags_Response;
}
impl ::steam_vent_proto_common::RpcMethod for CGameRecording_GetThumbnails_Request {
    const METHOD_NAME: &'static str = "GameRecording.GetThumbnails#1";
    type Response = CGameRecording_GetThumbnails_Response;
}
impl ::steam_vent_proto_common::RpcMethod for CGameRecording_GetTimelinesForApp_Request {
    const METHOD_NAME: &'static str = "GameRecording.GetTimelinesForApp#1";
    type Response = CGameRecording_GetTimelinesForApp_Response;
}
impl ::steam_vent_proto_common::RpcMethod
for CGameRecording_GetTimelinesForClip_Request {
    const METHOD_NAME: &'static str = "GameRecording.GetTimelinesForClip#1";
    type Response = CGameRecording_GetTimelinesForClip_Response;
}
impl ::steam_vent_proto_common::RpcMethod
for CGameRecording_GetTotalDiskSpaceUsage_Request {
    const METHOD_NAME: &'static str = "GameRecording.GetTotalDiskSpaceUsage#1";
    type Response = CGameRecording_GetTotalDiskSpaceUsage_Response;
}
impl ::steam_vent_proto_common::RpcMethod for CGameRecording_LowDiskSpace_Notification {
    const METHOD_NAME: &'static str = "GameRecording.NotifyLowDiskSpace#1";
    type Response = WebUINoResponse;
}
impl ::steam_vent_proto_common::RpcMethod
for CGameRecording_ManuallyDeleteRecordingsForApps_Request {
    const METHOD_NAME: &'static str = "GameRecording.ManuallyDeleteRecordingsForApps#1";
    type Response = CGameRecording_ManuallyDeleteRecordingsForApps_Response;
}
impl ::steam_vent_proto_common::RpcMethod
for CGameRecording_PostGameHighlightsChanged_Notification {
    const METHOD_NAME: &'static str = "GameRecording.NotifyPostGameHighlightsChanged#1";
    type Response = WebUINoResponse;
}
impl ::steam_vent_proto_common::RpcMethod for CGameRecording_QueryPhases_Request {
    const METHOD_NAME: &'static str = "GameRecording.QueryPhases#1";
    type Response = CGameRecording_QueryPhases_Response;
}
impl ::steam_vent_proto_common::RpcMethod
for CGameRecording_RecordingSessionChanged_Notification {
    const METHOD_NAME: &'static str = "GameRecording.NotifyRecordingSessionChanged#1";
    type Response = WebUINoResponse;
}
impl ::steam_vent_proto_common::RpcMethod for CGameRecording_SaveClip_Request {
    const METHOD_NAME: &'static str = "GameRecording.SaveClip#1";
    type Response = CGameRecording_SaveClip_Response;
}
impl ::steam_vent_proto_common::RpcMethod for CGameRecording_SetPerGameSettings_Request {
    const METHOD_NAME: &'static str = "GameRecording.SetPerGameSettings#1";
    type Response = CGameRecording_SetPerGameSettings_Response;
}
impl ::steam_vent_proto_common::RpcMethod for CGameRecording_StartRecording_Request {
    const METHOD_NAME: &'static str = "GameRecording.StartRecording#1";
    type Response = CGameRecording_StartRecording_Response;
}
impl ::steam_vent_proto_common::RpcMethod for CGameRecording_StopRecording_Request {
    const METHOD_NAME: &'static str = "GameRecording.StopRecording#1";
    type Response = CGameRecording_StopRecording_Response;
}
impl ::steam_vent_proto_common::RpcMethod
for CGameRecording_SwitchBackgroundRecordingGame_Request {
    const METHOD_NAME: &'static str = "GameRecording.SwitchBackgroundRecordingGame#1";
    type Response = CGameRecording_SwitchBackgroundRecordingGame_Response;
}
impl ::steam_vent_proto_common::RpcMethod for CGameRecording_TakeScreenshot_Request {
    const METHOD_NAME: &'static str = "GameRecording.TakeScreenshot#1";
    type Response = CGameRecording_TakeScreenshot_Response;
}
impl ::steam_vent_proto_common::RpcMethod
for CGameRecording_TimelineChanged_Notification {
    const METHOD_NAME: &'static str = "GameRecording.NotifyTimelineChanged#1";
    type Response = WebUINoResponse;
}
impl ::steam_vent_proto_common::RpcMethod
for CGameRecording_TimelineEntryChanged_Notification {
    const METHOD_NAME: &'static str = "GameRecording.NotifyTimelineEntryChanged#1";
    type Response = WebUINoResponse;
}
impl ::steam_vent_proto_common::RpcMethod for CGameRecording_UploadClipToSteam_Request {
    const METHOD_NAME: &'static str = "GameRecording.UploadClipToSteam#1";
    type Response = CGameRecording_UploadClipToSteam_Response;
}
impl ::steam_vent_proto_common::RpcMethod
for CGameRecording_UploadProgress_Notification {
    const METHOD_NAME: &'static str = "GameRecording.NotifyUploadProgress#1";
    type Response = WebUINoResponse;
}
impl ::steam_vent_proto_common::RpcMethod
for CGameRecording_UserAddTimelineEntry_Request {
    const METHOD_NAME: &'static str = "GameRecording.UserAddTimelineEntry#1";
    type Response = CGameRecording_UserAddTimelineEntry_Response;
}
impl ::steam_vent_proto_common::RpcMethod
for CGameRecording_UserRemoveTimelineEntry_Request {
    const METHOD_NAME: &'static str = "GameRecording.UserRemoveTimelineEntry#1";
    type Response = CGameRecording_UserRemoveTimelineEntry_Response;
}
impl ::steam_vent_proto_common::RpcMethod
for CGameRecording_UserUpdateTimelineEntry_Request {
    const METHOD_NAME: &'static str = "GameRecording.UserUpdateTimelineEntry#1";
    type Response = CGameRecording_UserUpdateTimelineEntry_Response;
}
impl ::steam_vent_proto_common::RpcMethod for CGameRecording_ZipClip_Request {
    const METHOD_NAME: &'static str = "GameRecording.ZipClip#1";
    type Response = CGameRecording_ZipClip_Response;
}
